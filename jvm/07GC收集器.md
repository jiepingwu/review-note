### GC收集器以及实现细节

#### 怎么判断对象已死？

- **Reference Count**，引用计数，当有变量引用时，增加一次引用计数，认为引用次数为0的对象需要被回收。这样做会在循环引用的情况下无法判断。

- **GC Root**，根可达分析，首先确定一些Root对象，作为根节点，根据Root对象的引用链，寻找标记引用的对象，最后没有被标记的节点为需要被回收的节点。

    - 哪些是GC Root？
        - 虚拟机栈中的局部变量表中的引用对象，如局部变量、方法参数等。
        - 方法区中的静态变量，常量池持有的引用。
        - 本地方法栈中的引用对象。
        - JVM内部的引用，比如基本数据类型对象的Class对象，系统类加载器等。
        - 被内置锁绑定的对象，synchronized持有的对象。

    

对于GC Root根可达分析，存在这样一个问题，在分代模型分代GC的情况下，有可能会存在 区域外的引用，JVM必须把这些区域外的引用也作为 GC Root。（这是怎么实现的呢？**通过记忆集，一种数据结构，将Young区中建立，记录哪些Old区域中存在对Young区的引用。**

#### GC收集算法

- 标记-清除：就是标记所有垃圾，然后直接清除，这样会产生内存碎片，空间利用率低。
- 标记-复制：标记完垃圾后，将存活对象复制到一块新的内存区域，由于不需要考虑内存碎片的问题，只需要移动堆顶指针，因此效率更高，但是这种方法将内存分为两块相等的区域，浪费空间。经典分代模型中的Young区则又分为了 Eden区和S1、S2区，Eden:S为8:2，只是空了Young区中10%的空间。
- 标记-整理：标记完垃圾后，将存活对象向前移动，保持整齐，存活对象占用连续的一块内存。这种方法的问题在于，移动指针需要STW(Stop The World)，（实现了用户线程和GC线程并行的GC除外），阻塞用户线程，知道GC线程完成移动对象的工作。
- 标记-清除，虽然不需要移动指针，不需要STW，但是会产生大量的内存碎片；而标记-整理和标记-复制则需要移动对象，一般需要STW(除了现代的GC回收器做了优化。)

***GC Root枚举时***

在确定Root集的时候，需要STW确保没有用户线程修改对象引用，而在GC Root的搜索或者说引用链搜索的过程中，则可以实现用户线程和GC线程的并行（如CMS、G1、ZGC等收集器）。

而在GC Root枚举确定Root集的时候，一个细节是不需要根据所有，而是使用一个**数据结构(OopMap)**记录哪些是对象引用。（在类加载的过程中，就知道了哪些是引用类型，在JIT即时编译过程中也会记录哪些是对象引用。）

***安全点***

安全点确定了什么时候进行GC(这里指的是什么时候开始进行垃圾的遍历收集)。

一般来说，我们可以在任意时刻进行STW然后进行GC收集，但是由于刚刚提到的，确定Root集合时，并不是扫描全部内存区域，而是使用了一个OopMap的数据结构记录了对象引用位置，因此，我们GC收集需要依赖这个数据结构，也需要维护这个数据结构，但是这个OopMap并不是每一条字节码指令都会更新一次，这样开销太大了。所以，jvm会在合适的时候更新这个OopMap，然后使用OopMap进行GC垃圾遍历收集。（合适的时候指的是：可能会使程序长时间执行的位置上。）

所以，jvm在程序执行到安全点的时候，进行STW然后进行GC垃圾的枚举收集，这里是依靠OopMap记录的对象引用中的哪些是GC Root，根据这些Root进行遍历。

***安全区域***

安全局域可以看成是一个大点安全点，对于被阻塞、或者没有被调度的用户线程，jvm不能将其停靠在安全点然后挂起自己，于是将没有执行的用户线程作为一个大的安全点，挂起整个线程直到GC线程完成GC的收集。

***记忆集***

记忆集上面提到了，是用来记录哪些是区域外引用的，用来进行GC Root的收集。因为在分代模型中，分代收集，但是可能会存在 跨代引用，比如Old区存在对Young区的对象的引用，这个时候，就需要将Old区的引用作为GC Root加入Root集。但是，我们不可能扫描整个Old区域，所以，jvm在Young区中维护了一个数据结构，也就是记忆集，用来记录 哪些 Old区域 持有了 对于 Young区的对象的引用，在进行GC Root的收集的时候，就也要将这些记忆集中的对象加入。

***卡表***

卡表是作为记忆集的一种具体实现，记忆集只是一种逻辑抽象。不同记忆集可以在精度上有所不同，比如卡表是记录了哪些内存区域上存在代外引用，卡表实现上可以是一个byte[]数组，每个数组元素映射上内存中的一块区域(也叫一个卡页，512bytes)，如果存在代外引用，则将byte[]中对应位置的元素置为1。在进行GC Root的收集时，查询卡表中哪些是为1的元素，就知道哪些对应的卡页存在代外引用，就可以加入GC Root中扫描。

拓展一下，卡表是怎么维护的？也就是说，这个byte[]什么时候被修改的，谁来修改的？

卡表是为了记录哪些区域存在分代外引用，所以，应该是在 **一个分代外对象的一个指针指向了该对象时(Object OldObj.member = new YoungObj();)**需要维护卡表，那么原理上怎么实现的？如果是解释执行的，那么可以通过字节码指令来进行维护卡表的工作，而如果是JIT编译执行，直接翻译为本地机器码，需要机器码层面实现，则jvm会在这些引用类型的赋值语句后生成一条维护 卡表的机器码指令（写屏障）。

***并行GC收集***

在进行GC Root的收集时，是必须要进行STW的，而在遍历引用链收集垃圾的过程中，则是可以实现GC线程和用户线程的并行的。（注意，这里指的是并行，而不是多线程GC并发）

使用到了一种算法-**三色标记算法**

- 黑色：对象以及对象持有的引用都被遍历完成了。
- 灰色：遍历到了对象节点，但是子节点没有遍历完。
- 白色：还没有遍历到的对象节点，并且对象中的引用（子节点）也还没有遍历。

这在STW的情况下，是没有问题的，但是如果是用户线程与GC并行，那么就可能存在两个问题：

1 垃圾标记为存活对象：这种情况下没有大问题，只需要下次GC标记就行。

2 存活对象标记为垃圾：将存活对象标记为垃圾是很严重的bug，很有可能造成系统崩溃。

对于"对象消失"，只有满足下面两种情况才可能发生：①一个黑色对象指向了一个新的白色对象。(导致新的白对象没有被遍历的机会）②并且没有灰色对象指向这个白色对象。（没有被遍历的二次机会）。最终导致该新的白色对象没有经过扫描，被当作垃圾进行回收了。

**解决对象消失的两个思路，就是破坏上面的两个条件其中之一。**

CMS：CMS通过破坏第一个条件防止对象消失，它叫做"**增量更新**"，**当一个黑色对象指向了一个新的白色对象时，将这个黑对象变为灰色对象。**

G1,ZGC：破坏第二个条件来防止对象消失，叫做"**原始快照**"，**当有灰色对象删除了一个对白色对象的引用时，保存一个快照，扫描时以这个还存在灰白指向的快照为标准。**



#### 经典GC收集器

经典的GC收集器有：Serial, Parallel New, Parallel Scavenge (Young区)；Serial Old，Parallel Old，CMS（Old区）；

**Serial，Parallel New 和 Serial Old，Parallel Old** 比较简单，Serial是单线程GC，而Parallel是多线程GC，new表示是Young区的GC收集器。Old是Old区的GC收集器。需要说明的是，Young区使用的是标记-复制，而Old区使用的是标记-整理。

**Parallel Scavenge**：和Parallel New一样都是Young区的GC回收器，区别在于它们两关注的侧重点不同，一般的GC收集器都是关注于降低GC时STW的时间，降低用户的响应时间；Parallel Scavenge则是侧重于提高 吞吐量：吞吐量 = (执行用户线程时间)/(执行用户线程时间+GC线程执行时间)

**CMS**：CMS实现了用户线程和GC线程并行执行，是最早的进行并行尝试的GC收集器，但是没有商用过，被更优秀的，如G1,ZGC取代。

- CMS是这样的：

- **1 进行GC Root的收集，这个过程需要STW；** 

- **2 GC线程和用户线程并行，使用3色标记算法，GC收集垃圾，这个过程中由于可能会导致 "对象消失"，所以需要进行重新标记。**

- **3 重新标记，通过增量更新，即改变上面提到的第1个条件，将一个黑色对象指向了新的白色对象时将该黑色对象变为灰色，这里就需要重新标记一次，并且是需要STW。** 

- **4 并发清除，使用标记-清除，多线程并发进行清除。**

**G1**：G1是一种面向局部收集的GC收集器，基于Region的内存布局，而不是经典的分代模型布局。

G1的目标是为了实现一个可以设置停顿时间的收集器，可以在指定时间内大概率完成GC工作。

- Region内存布局：G1采用Region区域式的内存布局，不再是对于某一个分代进行GC，而是可以对于堆中任意一块区域，组成回收集进行回收。G1中，将整个堆分为多个大小相等的区域(Region)，每个区域都可以被当作是Eden，Survivor，Old。G1对于不同的Region角色采用不同的策略。
- **G1设置停顿时间**：G1可以设置停顿时间，在指定时间内完成GC的原因在于：G1回收时，会对给个Region的回收价值维护一个价值排序列表，这样就可以根据用户指定的停顿时间设置 回收策略。
- **G1中的跨代引用**：G1同样的需要解决跨代引用问题，G1需要为每个Region维护一个记忆集，**内存开销比较大。**
- **G1中的对象消失**：G1通过 原始快照的方式防止对象消失，即 当灰色对象取消了对白色对象的引用时，保存一个快照，后面使用这个快照进行标记。**注意保存快照需要开销。**

**Shenanadoah**

和G1的回收策略大致相同，区别在于 最后的标记-整理阶段是和用户线程并行的，而G1的垃圾清理过程是需要STW的。

**ZGC**

ZGC非常的快，一句话概括：ZGC是基于Region内存布局的，不设分代的，使用了读屏障、**染色指针**和内存多重映射等技术实现的可并发标记-整理算法的，以降低用户线程延迟为目标的GC收集器。

ZGC中，将哪些是垃圾，标记在了指针上。