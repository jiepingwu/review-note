### JVM的架构模型

#### JVM是什么？

JVM简单来说就是运行在OS中的一个程序，所有的java都被编译成字节码后由JVM编译成机器码执行，JVM提供执行java代码的安全性保障、管理运行时内存、以及执行引擎中的解释器和编译器生成机器码、GC机制等功能。

#### JVM架构

![Image](F:\研究生\review-note\references-figures\Image.png)

JVM可以分为这样几个部分：

类加载系统、运行时数据区、执行引擎、以及本地方法接口、本地方法库。

#### 类加载系统

- 类加载器负责将编译的class文件，加载进内存，中间有 加载->连接(验证、准备、解析)->初始化的过程。（具体过程见 *JVM类加载机制*）
- 这里简单说下
- 加载过程 会存在 **双亲委派机制**，为了确保 代码的安全性，避免加载了一个类库中以及实现的重名类。有三个类加载器，**Bootstrap ClassLoader引导类加载器、ExtClassLoader拓展类加载器和AppClassLoader应用类加载器**，引导类加载器用于加载核心类库中的类，拓展类加载器加载存放在ext目录下的用于拓展类库的类，应用类加载器则加载class path上的所有类库。双亲委派的过程如下：加载一个类时，首先自底向上委派，委派给父加载器进行加载，如果父加载器加载过该类，那么直接返回，否则向上委派，直到Bootstrap ClassLoader，之后自顶向下执行类加载，无法加载则委派给子加载器，如果所有子加载器都不能完成类加载，那么抛出ClassNotFoundException。
- 破坏双亲委派的例子，其实一个例子就是 JDK9中引入的java模块化系统，该系统 使用了 BootStrap ClassLoader(引导类加载器)、PlatformClassLoader(平台类加载器)、ApplicationCL(应用程序类加载器)、自定义类加载器(UserCL)。
- JDK9中引入模块化之后，类加载器其实就不是典型的双亲委派了，而是像是"家族委派机制"，类加载时会先到其它的某一个类加载器负责的模块中查询，是否存在，（也就是说，AppCL会查询PlatformCL和BootstrapCL中是否加载过，PCL则会查询ACL和BCL中是否记载过，直到这些加载器都无法完成类加载）。



#### 运行时数据区

运行时数据区，用于管理程序运行时用到的所有数据。包括这样几个部分：**虚拟机栈、堆、方法区、PC寄存器、本地方法栈**。

***VM栈***

线程执行方法时的调用栈，每次创建线程时都会在虚拟机栈中创建一个对应的线程栈，执行方法时会创建一个栈帧入线程栈。

栈帧中有：**局部变量表、操作数栈、方法返回地址、动态连接**。（具体内容见JVM字节码执行引擎)。

需要注意的是：VM栈中也可能分配对象，当对象不能逃逸出当前线程，也就是不会被其它线程引用时，则可以直接将对象分配在线程栈中。

***堆***

堆是用来存放创建的对象实例的，java中几乎所有的对象都分配在堆中。

**根据经典分代模型**，堆中分为Old区和Young区两个部分（默认比例2：1），Young又分为Eden、Survivor from、Servivor to三个区域（比例8：1：1）。

这样分是因为：首先，因为大部分对象都是马上消亡的，而大部分不会消亡的对象大概率也会长时间存在，所以分为Old区和Young区两个区，Old区存放"顽固对象"，Young区存放新生对象，避免对于顽固对象的扫描。然后，如果Young区内部不分区，那么在Young区中使用标记-清除的话就会存在大量的 **内存碎片**，如果使用标记-整理的话移动对象单线程很慢，而多线程需要解决并发问题。所以，在Young区中，又分为Eden和Sruvivior两个区域，将整个Young进行YGC后的存活对象通过标记-复制移动到Survivior区域中，标记-复制不需要考虑内存碎片的问题，只需要移动分配指针就行。然后，这样的话，S区域中在YGC后依然会存在内存碎片，于是，又将S区分为S1和S2，S1和S2总有一个是空的，每次将YGC后的存活对象移到空的S区。

**另外、堆中还有一块比较重要的区域，叫做 线程本地分配缓冲区。**

线程本地分配缓冲区（Thread Local Allocation Buffer，TLAB）。

这是什么？为什么会有这个 *线程本地分配缓冲区？*

TLAB是 堆中 为 每个线程 预先分配的内存区域，线程需要分配对象的时候，就在对应的 TLAB中分配。

看出来了吧，这是为了对于分配内存进行线程隔离。因为，**分配内存在并发情况下也是线程不安全的，需要同步，**而为了减少一些同步带来的消耗，使用TLAB进行线程隔离，每个线程只在自己拥有的本地分配缓冲区中分配对象。

***内存分配都不是线程安全的，那么JVM是怎么做的同步呢？***

内存分配有两种方式：1 只移动指针，这需要要求内存可用空间是连续的。2 列表记录所有可用的空间位置。

除了使用刚刚说到的 Thread Local Allocation Buffer，JVM通过**CAS+自旋**的方式更新 指针或者列表记录。

在JVM中，先分配到对于的TLAB，如果buffer满了，则CAS+自旋的方式移动指针，或者更新列表记录。(Atomic::cmpxchg_ptr)

***方法区***

方法区存放静态变量、常量、Class对象、常量池等。也就是一些共享数据。

需要注意的是：在类加载后，.class的二进制字节流会被封装为一种数据结构存放在方法区中，然后在堆中创建一个对象作为操作该数据结构的入口。

运行时常量池时方法区的一部分，在加载.class文件时，class文件除了有 类的版本信息、字段、方法、接口等描述性信息外，还有一项是 常量池表，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区。

另外，方法区只是一个逻辑概念，现在方法区实现在 metaspace，之前实现在永久代。

***PC寄存器***

用于线程的上下文切换，每个线程独享，CPU进行上下文切换时需要记录当前线程的执行状态，以便切换时恢复到之前的运行状态，PC寄存器就用来记录每个线程执行的字节码指令的内存地址。

***本地方法栈***

用于执行本地方法的栈，和虚拟机栈一样，其实它们两在实现上没有区分。

***堆外内存***

内核态中的内存，JVM无法直接管理，但可以间接管理。

比如NIO中基于Channel和Buffer的IO方式，它直接使用本地方法分配堆外内存，然后通过一个堆中的DirectByteBuffer对象作为这块堆外内存的引用进行操作。从而避免了内核态和用户态的来回复制。



#### 对象的创建过程

Q：讲讲对象的创建过程是怎么样的，new一个对象的过程是怎样的？

A：

- 从new object开始说，当JVM遇到一条字节码new指令时，首先是类加载检测，检查该类是否已经被加载，连接，初始化过，如果没有，则首先需要进行类加载。

- 类加载检查通过或者完成后，申请内存空间，对象分配在哪里需要进行逃逸分析，如果逃逸出线程，那么就需要分配在堆上，然后首先会在 *Thread Local Allocation Buffer 线程本地分配缓冲区* 中分配空间，如果TLAB满了，则需要通过CAS+自旋的方式移动指针，在堆上分配空间。

- 空间分配完成后，初始化对象，也就是把实例变量赋为 默认值（0值），注意此时是默认值，也就是半初始化状态。

- 设置对象对象头head中的数据，如 hashcode, GC分代年龄，类元数据，锁的相关信息，GC相关信息等。

- 此时，在JVM看来对象就已经完成创建了，也就是执行完了new字节码指令，但在java代码看来，才刚刚开始，构造函数还没有开始执行。

- new字节码指令完成后，执行init指令，也就是执行对象的初始化操作。init字节码执行构造函数，进行初始化操作。

- 最后发布对象的引用，引用变量进行接收。

- 另外，这里创建对象的过程，大致就三步，分配空间，半初始化对象，初始化对象，发布引用。其中，半初始化对象，初始化对象，发布引用的过程，可能会发生指令重排序，也就是说，可能发布了一个半初始化对象的引用。

- 这就是著名的面试题：*DCL单例中单例字段需不需要加volatile？*

    

#### 对象的访问方式

因为需要知道对象的类元信息。

对象的访问方式分为两种：1 直接访问 2 句柄访问。

直接访问：栈中的变量直接指向堆中的对象，堆中的对象中保存了类元信息的引用。

句柄访问：栈中的变量指向堆中的句柄池中的句柄，句柄分别指向堆中的对象和类元信息数据。

优缺点：直接访问减少了一次指针定位，因为对象访问非常普遍，所有这个开销减少的很可观。句柄访问，则是在 对象移动的时候，只需要更改句柄池中 指向对象的句柄，而不需要更改栈变量的指针。



#### 对象的内存布局

对象的内存布局组成：

1 对象头：对象头包含对象的运行时数据，由MarkWord、Class Pointer、Length（数组特有）。

具体说分为三部分：

**MarkWord**：存放hashcode，GC分代年龄，锁标记、偏向锁线程ID、GC信息等。

**Class Pointer**：对象的类元信息对象的引用。

**Length**：数组特有，记录数组对象的长度。

2 实例数据：存储对象的成员变量。其中reference类型为8byte。

3 对齐填充：用于填充对象，使对象占用为8的倍数的字节数。这样就方便移动指针进行内存访问，不需要知道到底需要移动多少位，每次移动8个字节就行。

![Image](F:\研究生\review-note\references-figures\Image-1620736648409.png)