### JVM字节码执行引擎

#### 编译执行还是解释执行？

解释执行：将字节码一条一条翻译为机器码执行。

编译执行：将字节码以方法为单位翻译为机器码，并且保存在本地。

JVM执行其实是解释执行+JIT即时编译器编译执行一起实现的，JIT动态的将热点代码编译为本地机器码。

#### 运行时的栈帧数据结构

栈帧是用于JVM进行方法调用和方法执行的数据结构，进行方法调用时，JVM创建一个栈帧压入线程栈中，栈帧中保存执行方法需要的局部变量表、操作数栈、动态连接和方法返回地址等信息。

需要知道的是：在编译java源码为class文件时，需要多大的局部变量表、操作数栈就已经被分析出来，并且被保存在class文件的方法表的code属性中。

##### 局部变量表

局部变量表存放 局部变量 和 方法参数。

需要关注的是：

局部变量表以一个slot变量槽为单位，JVM虽然没有规定一个slot有多大，但是JVM规定了一个slot需要放的下byte\short\int\long\float\boolean\char\reference和returenAddress类型的数据，(注意，这里没有long和double等8bytes类型)，也就是说一个slot至少是4bytes，32位。*另外，reference类型开启指针压缩为 4bytes，32位。*而对于long、double这样的8字节类型，需要使用两个变量槽保存，并且JVM规定两个变量槽的访问必须同时，不能只访问其中的一个slot。

而**变量槽可以被复用**，这也就是名言 **当不需要使用对象时，应该显示地将变量引用置为null。**

这里的原理其实在于，**当线程的PC计数器超出了某个变量的作用域，那么这个变量的变量槽就可以被重用。**但是注意，这里其实需要进行一次局部变量表的读写，才会重用变量槽。*如图，离开了placeholders的作用域后，需要进行一次局部变量表读写，才能重用变量槽。*这才是将对象置为null的原理。

另外，这句话并不正确，因为将一个对象置为null这种操作会被JIT即时编译器优化后当作无效操作消去。

![](F:\研究生\review-note\references-figures\Image-1620738164223.png)

![Image](F:\研究生\review-note\references-figures\Image-1620738155005.png)

##### 操作数栈

当一个方法刚开始执行时，这个方法的操作数栈是空的，执行过程中字节码指令 往操作数栈中写入和提取内容。比如 a+b，首先会将a和b变量压入操作数栈，接着调用iadd指令，取出栈顶的两个元素，相加，最后将结果压入栈中。

##### 动态连接

每个栈帧中都包含一个指向运行时常量池中所属方法的引用，由于支持方法调用过程中的动态连接。

##### 方法返回地址

存放调用方法的字节码指令的地址，也就是PC寄存器的值。



#### 方法调用

方法调用过程需要确定调用方法的版本，确定方法版本的方式可以分为 解析 和 分派。

解析：在编译器就能够确定唯一的方法版本，比如没有被重载和重写的静态方法和私有方法。

分派：分派则是和 重载 和 重写 的实现相关，首先 我们需要知道 静态类型 和 实际类型，重载是根据参数的静态类型来确定方法的执行版本。而重写则是依赖于对象的实际类型来确定方法的版本，原理上是通过 invokevirtual指令来实现，调用invokevirtual的执行过程是这样：找到对象的实际类型，如果在实际类型中找到对应的方法，则执行，没有则按照继承关系向上寻找。