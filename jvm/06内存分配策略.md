##### 内存分配策略

一个对象，它在内存中是怎么被分配的？

这里谈的内存分配，基于经典分代模型，也就是Young区(Eden, S1, S2)和Old区这种堆分区模型。

先聊聊经典分代模型，为什么要这么分区。

分代模型首先基于一个理论：大多数对象都是很快就消亡的，而不是很快消亡的对象大概率也会顽固的存活很长时间。

于是，首先可以分为 Young区 和 Old区，新生对象放入Young区，而长时间存活的对象则放入Old区，一般对象创建时就放入Young区，只有当Young区放不下了，或者对象经过GC存活的次数过多，则进入Old区变为顽固分子。

这里，分为Young区和Old区有一个问题，就是如何进行GC呢，对于Young和Old，我们应该一般进行Young区的GC，少进行Old区的GC，因为Old区都是顽固分子，很大概率GC收不掉。对于Old区来说，我们可以使用标记-整理算法，而对于Young区，如果使用 标记-清除，则会产生大量的碎片，如果使用标记-整理，那么就太慢了，所以，我们又将Young区分为两个部分 Eden区和Survivor区，对象先分配到Eden区，Eden区分配不下，进行YGC，将存活对象移动到S区，这同样会在S区中产生内存碎片，于是S区又分为两个区S1和S2，它们两中总有一个是空的，Eden区分配不下，YGC后存活对象通过-标记-复制，复制到空的S区，下一次同样GC后复制移动到另一个空的S区，当S区也分配不下了，则会分配到Old区中，Old区也分配不下，进行Full-GC，FGC还是分配不下，抛出OutOfMemmoryException。

*这里，注意一个问题，对象不是一定会分配在堆上的。*

当逃逸分析分析对象不会逃逸出线程，也就是说，对象不会被其它线程引用，那么它就可以直接分配在线程栈中。

另外，堆中还有一块区域，叫做 Thread Local Allocation Buffer（线程本地分配缓冲区），这个区域是在堆中预分配的线程隔离的区域，用于线程分配对象时直接分配，避免多线程分配内存中产生的并发问题（比如抢分配指针）。