### 锁、锁的升级

#### java中的锁

**synchronized**

synchronized是java中的内置锁，提供了多线程对共享资源的互斥访问功能。为了优化性能，jvm实现了synchrinized锁的升级过程。升级最后synchronized的内置对象锁是基于操作系统的互斥量锁，在操作系统中有一个监视器对象，对象中会记录当前持有锁的线程，以及维护一个请求该锁的等待队列。

**synchronized的实现**上，转换为字节码后，进入同步代码块时加上 **moniterenter**指令，退出时加上**moniterexit**指令。执行moniter enter时，会请求锁，CAS将监视器对象中的状态量置为1，CAS成功的作为当前持有锁的线程，失败的进入等待队列，等待下次抢锁；执行moniter exit时则会检查状态量state是否为1（由于锁会重入，只有为1时才真正释放锁），为1时释放锁，唤醒队列中的线程抢锁。

***synchronized的问题***

synchronized没有异常处理机制，也不响应中断，也没有记时等待的功能，请求锁失败一定会被阻塞。另外，内置锁是非公平锁，也就是说，没有请求锁的先后顺序，所有请求锁的线程都有可能抢到锁，也就是说synchronized不提供公平锁实现。

**ReentrantLock**

为了解决上面的问题，道格~李造了新轮子-ReentrantLock，可重入锁。ReentrantLock可以响应中断，也可以处理异常，可以记时请求锁。简单来说，ReentrantLock基于AQS实现，AQS维护了一个 同步队列，和带有锁的语义的int变量 state，state在不同的同步器实现中含有不同的语义，在ReentrantLock中，它是互斥锁，并且可以是非公平的或者公平的，默认是非公平锁。请求锁的时候，尝试CAS修改state为1，如果成功，则抢到锁，线程执行；如果修改失败，则将线程包装为一个节点CAS+自旋地放到同步队列的最后，并且自旋判断是应该被唤醒还是继续阻塞（这里其实将节点放到合适的位置上，当前面节点为signal状态时，释放锁后则会通知后继节点抢锁）。

**锁的升级过程**

锁的升级过程涉及到java的对象内存布局，如下图。

![Image](F:\研究生\review-note\references-figures\Image-1620736648409.png)

升级过程是这样的：

1. **new一个对象，之前的版本默认是无锁态，而新版本jdk(jdk9?)后new一个对象默认开启偏向锁**，偏向一个Dummy对象，可以参数关闭。
2. **当第一个线程请求该锁的时候，升级为偏向锁状态，并且通过CAS将锁对象中的偏向锁线程ID设为当前线程。**（注意，这里对象的hashcode被覆盖了，那怎么办呢，当偏向锁状态下，调用对象的hashCode方法，这里指的是IdentityHashCode方法而不是重写的方法，重写方法不需要在这里查询，就会直接撤销偏向锁，直接升级为重量级锁，锁对象指向重量级锁对象MoniterObject，该对象中保存了原对象无锁状态下的Mark Word。）
3. **当第二个线程请求该锁的时候，检查持有锁的线程是否释放锁，如果释放，则偏向锁撤销，进行重偏向；而如果偏向线程还是持有偏向锁，则锁撤销，然后升级为CAS锁（也叫轻量级锁、无锁），将对象的Mark Word保存在当前线程栈中，并且对象头中CAS修改，指向该Mark Word副本(叫做 Lock Record锁记录)，其它线程请求锁时，都通过CAS+自旋的方式将 对象头MarkWord中的 指向LockRecord指针改为指向自己线程栈中的LockRecord。**
4. **CAS自旋需要消耗CPU资源，不可能让它一直或者长期在那里转，所以，当CAS自旋超过一定次数后（无自适应自旋前为10次）或者CPU使用率过高时，升级为重量级锁，重量级锁通过OS维护的一个锁对象，锁对象持有一个队列，将请求锁失败的线程放入该等待队列中，由OS进行唤醒和阻塞的操作。**重量级锁的问题在于需要OS的帮忙，会在内核态和用户态切换，并且OS请求锁资源也是比较消耗资源的一个操作。

另外，*自适应自旋*，是JVM对于CAS锁的一种优化，对于长期CAS的还是没有抢到锁的线程，增加自旋次数，对于很快就能CAS抢到锁的线程，减少自旋次数。