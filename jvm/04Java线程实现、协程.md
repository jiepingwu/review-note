### Java线程实现、协程

我们知道，线程是比进程更轻量级的调度执行单位，各个线程既可以共享进程资源，又可以独立调度。

我们先来看看 通用的线程 是如何实现的？

线程的实现方式一般有3种，分别为 **使用内核线程实现(1:1)，使用用户线程实现(1:N)，使用用户线程加轻量级进程混合实现(N:M)**

1. 内核线程：内核线程是直接由操作系统支持的线程，这种线程由操作系统来进行切换和调度，程序中不会直接使用内核线程，而是使用内核线程的高级接口-轻量级进程，每个轻量级进程由一个内核线程支持，也就是1：1线程模型。由于内核线程的支持，每个轻量级进程都是独立的调度单元，即使其中一个因为系统调用而阻塞，也不会阻塞整个进程。而，内核线程实现的缺点在于：由于基于内核线程实现，所以线程的创建、调度都需要进行系统调用，因为系统调用需要涉及到用户态和内核态的线程切换，消耗较高；而且，1:1线程模型，需要消耗内核空间资源，如内核线程栈，内核线程的数量是有限的，因此系统支持的轻量级进程的数量是有限的。
2. 用户线程：用户线程是指建立在用户空间的线程库上，线程的创建、销毁、调度、同步都在用户态完成，不需要内核的帮助，不需要内核态和用户态的切换。所以很高效而且可以支持更多的线程数量1:N。缺点在于，没有内核态的帮助，线程的管理实现非常的困难。
3. 混合实现：用户线程和内核线程一起使用，用户线程还是在用户态，OS支持的内核线程的接口(轻量级进程)作为用户线程和内核线程的桥梁，用户线程系统调用使用轻量级线程完成。

##### java线程实现

java线程是使用原生的操作系统线程实现的，也就是内核线程1:1的实现方式，所有的线程管理、调度、同步，都由操作系统进行。

##### 线程的状态转换

**New**：新建后还没有启动的线程。

**Runnable**：包含OS线程状态中的Running和Ready，可能被系统调用运行，也可能还没有运行。

**Waiting**：无期限等待状态，不参与调度，等待被其它线程唤醒。

调用Object::wait()、Thread::join()、LockSupport::part()等方法。

**Time Waiting**：记时等待状态，不参与调度，知道被其它线程唤醒或者到达时间。

调用Object::wait(timeout)、Thread::sleep()、Thread::join(timeout)、LockSupport::parkNanos()、LockSupport::parkUntil()等方法。

**Blocked**：阻塞状态，等待着获取一个排他锁，而等待状态则是等待唤醒或者时间结束。

**Terminated**：终止状态，线程结束执行。