### 类加载机制

类加载过程为：加载 --- 连接(验证、准备、解析) ---- 初始化。

- 加载

    通过类的全限定名获得用于定义此类的二进制字节流。将这个字节流转化为某种数据结构保存在 方法区 中，并且在堆中创建一个Class对象作为该数据结构的操作入口。

- 验证

    验证字节码文件的二进制字节流是否符合Class文件的规范，比如魔数0xCAFEBABE开头，版本号是否在JVM接受的范围等。

- 准备

    为类中定义的静态变量赋初始值，其中如果是final常量，则直接赋予final常量的值，因为这个值是在编译期就生成了。

- 解析

    解析阶段是将class文件的常量池中的符号引用转化为直接引用的过程，符号引用指使用一组符号来描述引用的目标，可用是任何形式的字面量，只要使用时能定位到目标就行，如JVM内存无关。直接引用指直接指向目标的指针，或者间接定位的句柄，跟内存直接相关。

- 初始化

    执行clinit字节码指令，进行真正的类的初始化操作，clinit字节码指令是在javac编译生成的，编译器自动收集static静态代码块，和所有静态变量的赋值语句，合并生成的。

    **需要关注的是，JVM需要保证clinit方法在多线程中执行时的线程安全性，也就是说如果多个线程同时区初始化一个类，那么只有其中一个线程可以执行clinit初始化，其它线程都被阻塞，并且，同一类加载器下，一个类型只会被初始化一次。**

    *这其实是 单例模式中的 静态内部类 写法能保证线程安全单例的原因。*

    ```java
    public class Singleton {
        private Singleton() { }
        private static class Holder {
            private final static INSTANCE = new Singleton();
        }
        public Singleton getInstance() {
            return Holder.INSTANCE;
        }
    } 
    ```

*另外，类加载器的双亲委派机制已在 00JVM架构 中提到。*