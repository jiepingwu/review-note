### Memory引擎的特点

都说InnoDB好，那还要不要使用 Memory 引擎 ？

#### 内存表的数据组织结构

考虑下面的SQL语句序列：

```sql
create table t1(id int primary key, c int) engine=Memory;
create table t2(id int primary key, c int) engine=innodb;
insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);
insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);
```

t1 和 t2 两张表，其中t1使用 Memory 引擎，t2使用 innodb 引擎，都插入10条记录。

然后分别执行 select \* from t1 和 select \* from t2。

![img](https://static001.geekbang.org/resource/image/3f/e6/3fb1100b6e3390357d4efff0ba4765e6.png)

结果会发现，内存表t1的结果中0在最后一行，而InnoDB表t2表中0在第一行，这是因为两个引擎的主键索引组织方式不同引起的。

InnoDB引擎的索引组织方式我们很熟悉了，数据就放在主键索引树中，主键索引是B+树。主键索引有序存储，在执行select的时候，就会使用叶子节点的双向链表从左到右扫描，所以0就在第一行。

Memory引擎中，**数据和索引是分开存放的，**内存表中的数据部分以数组的方式单独存放，而在主键id索引中，存的是每个数据的位置，主键id是hash索引，所以索引上的key不是有序的。当我们执行select的时候，走的是全表扫描，也就是扫描这个数组，所以0因为是最后一个加入的，也就是最后一个被读到。

从上面可以看到 InnoDB 和 Memeory的不同：

1. Innodb总是有序存放的，而 Memory 的数据以数组的方式存放，按照写入的顺序加入数组中。
2. 当数据文件有空洞时，InnoDB表在插入新数据时，依然要保证数据有序，只能在特定的位置写入新值，而Memory表找到空位就可以插入新值。
3. 当数据位置发生变化时，InnoDB只需要改变主键索引而不需要改变非聚簇索引(由于非聚簇索引存放的是主键索引ID)，但是Memory则需要改变所有索引。
4. InnoDB使用主键索引时需要一次索引查找，而使用普通索引则需要回表，走两个索引树，但是Memory表中所有索引地位是一样的。
5. InnoDB支持变长类型，不同记录的长度可能不同，而内存表不支持Blob和Text字段，斌且即使定义了varchar(N)，实际也会当作char(N)，内存表中每行数据长度相同。

需要知道的是：**Memory由于其索引结构，是不支持范围查询的。**

比如：select \* from t1 where id <= 5; 范围查询是用不上索引的，会走全表扫描。

那如果要让内存表支持范围扫描，应该怎么办呢？实际上，Memory内存表也是可以使用B-Tree索引的。

##### **hash索引和B-Tree索引**

比如，在id列上创建一个B-Tree索引，SQL语句可以这么写：

```sql
alter table t1 add index a_btree_index using btree(id);
```

![img](https://static001.geekbang.org/resource/image/17/e3/1788deca56cb83c114d8353c92e3bde3.jpg)

然后，内存表数据结构就变成了上面这个样子，会新增加一个 B-Tree 结构的主键索引（同时原Hash表主键索引也会存在）。

作为对比，刊下面两个语句的输出，第二个使用 force index强行使用Hash表索引，所以0会在末尾，但是第一个使用B-Tree所以，所以返回结果是0-4。

![img](https://static001.geekbang.org/resource/image/a8/8a/a85808fcccab24911d257d720550328a.png)

#### **内存表的优势**

快，其中一个原因是Memory引擎支持hash索引，读写都很快，但不支持范围查询，或者使用了B-Tree索引的范围查询就没有快的优势；另一个原因是 Memory 数据都存放在内存中，所以内存读写快。

#### **不建议使用内存表的原因**

##### 锁粒度问题

内存表不支持行锁，只支持表锁，所以，一张表只要有更新，就会阻塞其它所有在这个表上的读写操作。跟行锁相比，表锁并发度较低，所以，内存表的锁粒度问题，决定了它在处理并发事务时，性能不会太好。

##### 数据持久化问题

内存表数据是存放在内存中的，所以，如果数据库异常重启，所有的内存表也就被清空了，数据不能持久化存储。

并且，内存表在 M-S 架构下还有一个特性，Memory由于内存表会重启后清空，为了保证主备一致，它会在重启前记录一条log 到 bin log中，这条log就是清空内存表。这个bin log传到主库后，会将主库的内存表数据清空，这就很难受了。

这样看来：

1. 考虑并发度，支持行锁的InnoDB可以支持更好的并发度。
2. 考虑读写性能，一个读QPS很高并且数据量不大的表(因为存在内存表中的数据量都不会太大)，即使使用InnoDB，数据也会缓存在InnoDB buffer pool中，所以InnoDB表的读性能也不会比内存表差多少。

**所以，建议所有普通的内存表都可以使用InnoDB表代替，但有一个例外。**

就是：使用内存表来代替InnoDB临时表。

原因在于：

1. 临时表不会被其它线程访问，不存在并发问题。
2. 临时表也是会被重启删除的，不需要考虑持久化问题。
3. 备库的临时表也不会影响主库的用户线程。

了解了内存表的特性，内存临时表的效果更好，原因有三个：

1. 相比于 InnoDB 表，使用内存表不需要写磁盘，往表 写数据的速度更快；
2. 索引 b 使用 hash 索引，查找的速度比 B-Tree 索引快；
3. 临时表数据较少，占用的内存有限。