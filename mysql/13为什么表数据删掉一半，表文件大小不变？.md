### 为什么表数据删掉一半，表文件大小不变？

下面我们来看看 **数据库表的空间回收**

以 **innoDB引擎展开讨论，innoDB表包含两个部分：1. 表结构定义 2. 数据。在MySQL 8.0之前，表结构保存在一个以.frm为后缀的文件中，而 8.0后，表结构可以被保存在 系统数据表中。表结构定义占用的空间比较小，下面主要讨论 表数据的部分。**



两个问题：**1.、为什么简单地删除表数据达不到表空间回收的效果？2、怎样进行正确的空间回收？**

#### 1. 为什么简单地删除表数据不能回收空间？

##### 参数 innodb_file_per_table

​	表数据既可以存放在 **共享表空间** 中，也可以存放为 **单独的文件**，由参数innodb_file_per_table (每个表一个文件)控制。

​	OFF：表数据存放在共享表空间中。ON：表数据存放在一个.ibd后缀的文件中。

​	**推荐设置为ON，即使用单独的文件存放表数据，这样容易管理，而且在drop table删除表的时候，如果是单独文件，MySQL会直接删除文件，而如果是放在共享空间中，那么即使表删除了，空间也不会回收。**

​	**在设置为 单独文件保存表数据 的情况下，如果使用 drop table删除表时，可以回收表空间，但是，许多情况是删除行数据而不是表，这个时候就会存在不会回收空间的问题。**



##### 数据删除流程

​	前面我们知道索引是用B+树实现的，数据删除的过程，就是 **将数据标记为删除，如果之后插入一个数据就可以复用这个位置，但是磁盘文件大小是不会改变的。**

​	比如下图中，我们要删除R4这个记录，InnoDB只会将R4这个记录标记为删除，之后如果插入一个ID在300-600之间的数据时，就会复用这个位置，但是磁盘大小不会改变。

![image-20210529205941698](..\references-figures\image-20210529205941698.png)

##### 数据页的复用和数据记录的复用的不同

​	如果是复用一个数据页，那么该页可以存放任意的数据，而如果只是复用一个数据记录，那么只能用于复用该位置对应范围中的数据。(很好理解吧。)

​	另外，如果两个逻辑相邻的数据页的利用率都很小，innodb会把这两个数据页合并，空闲的数据页就可以被复用。



所以，如果是使用 delete 删除了表中的所有数据，那么就会使所有的数据页变为 **可复用状态**，但是磁盘大小是不会改变的。

##### 删除、插入、更新 都可能会导致 "空洞"

​	我们上面看到，删除可能会使数据页或者数据位置被标记为 可复用，也就是"空洞"，但是磁盘空间不会被回收。

​	不只是删除，插入和更新都可能导致上述的"空洞"，**当一个数据页已经满了的时候，如果我们需要往这个数据页中插入数据，那么就会导致数据页的分裂，可能会导致数据页分裂后留下空洞。**而 更新 操作可以看成是先删除在插入的，所以也会造成"空洞"。

​	如下图，我们在pageA数据页满的时候，插入一条ID=550的数据，导致pageA的分裂留下空洞。

![image-20210529205928957](..\references-figures\image-20210529205928957.png)

​	**所以，一个经过大量 增删改的表，都可能会存在空洞，所以，如果我们能把这些空洞去掉，就能够达到 收缩表空间的目的。**



#### 2. 怎样进行正确地回收表空间？

​	怎样，进行回收表空间，也就是说，这些在删除表数据时只是被标记为可复用的"空洞位置"或者"空洞数据页"，怎么被回收？

​	如果我们来做，我们怎么做？

​	我们可以新建一个与 表A(需要被回收空间的表) 相同表结构的表B，然后按照主键ID递增的顺序，将数据一行一行地从表A读出来插入到表B中。因为表B是新建的表，顺序插入不会存在空洞，所以表B的主键索引更紧凑，数据页利用率也更高。然后我们可以把表B作为临时表，当导入表B的操作完成后，使用表B代替表A，就达到了收缩表A空间的效果。

​	而上面的操作，我们可以使用 **alert table A engine=InnoDB** 命令来完成，重建表。

##### 重建表中会存在什么问题？

​	我们想想重建表的过程会存在什么问题，我们在将表A的数据插入到新表B的过程中，这个操作是一个视图操作，也就是说 这个过程中，如果有向表A中更新的数据，那么这个更新将会丢失。也就是说，整个DDL过程不是Online的。

​	在 MySQL 5.6之后引入了 Online DDL后，对于这个 alert table A engine=InnoDB 重建表的操作进行了优化。

##### 使用Online DDL的重建表流程

1. 建立一个临时文件，扫描表A主键的所有数据页
2. 用数据页中表A的记录生成B+树，存储到临时文件中
3. 生成临时文件的过程中，将所有对于 表A的操作记录在一个 **日志文件(row log) 中**，对应的是图中state2的状态
4. 生成临时文件后，将日志文件中的操作应用到临时文件，得到逻辑与表A相同的数据文件，对应state3的状态
5. 使用临时文件替换表A的数据文件

![QQ截图20210529213536](..\references-figures\QQ截图20210529213536.png)

**简单来说，就是使用一个row long日志，记录了在 重建表的过程中对应原来表的所有更新，然后在重建完成后使用这个 row log日志进行逻辑更新，保证与当前表A中数据逻辑一致。**



*一个问题：***DDL 需要拿到 MDL写锁，那么它还是Online DDL吗？**

前面讲锁的时候我们知道，为了保证DDL过程中不存在修改数据的操作，会拿到MDL写锁，任何修改数据的操作都会被阻塞。**而在 Online DDL中，也是需要获取MDL写锁，但是为了Online，MDL写锁会很快地退化成MDL读锁，退化成MDL读锁后，不会阻塞增删改数据的操作，但是禁止其他线程同时进行DDL。**

也就是说Online DDL的意思是：允许在DDL的过程中进行数据的修改，但还是不允许其他线程同时进行DDL。通过将进行DDL时获取的MDL写锁退化成MDL读锁完成，并且数据的修改被记录到row log日志中，DDL完成后同步row log中数据，达到逻辑一致。



*补充一点：* 上面的重建过程需要扫描原表数据以及构建临时文件，对于很大的表来说，是很消耗IO和CPU资源的，如果是线上服务，需要很小心地控制操作时间。如果要安全的操作，建议使用：GitHub开源的 压缩表空间的工具 **gh-ost**。



##### Online 和 inplace

（1）Copy Table方式
这是InnoDB最早支持的创建索引的方式。顾名思义，创建索引是通过临时表拷贝的方式实现的。

新建一个带有新索引的临时表，将原表数据全部拷贝到临时表，然后Rename，完成创建索引的操作。

这个方式创建索引，创建过程中，原表是可读的。但是会消耗一倍的存储空间。

（2）Inplace方式
这是原生MySQL 5.5，以及innodb_plugin中提供的创建索引的方式。所谓Inplace，也就是索引创建在原表上直接进行，不会拷贝临时表。相对于Copy Table方式，这是一个进步。

Inplace方式创建索引，创建过程中，原表同样可读的，但是不可写。

（3）Online方式
这是MySQL 5.6.7中提供的创建索引的方式。无论是Copy Table方式，还是Inplace方式，创建索引的过程中，原表只能允许读取，不可写。对应用有较大的限制，因此MySQL最新版本中，InnoDB支持了所谓的Online方式创建索引。

InnoDB的Online Add Index，首先是Inplace方式创建索引，无需使用临时表。在遍历聚簇索引，收集记录并插入到新索引的过程中，原表记录可修改。而修改的记录保存在Row Log中。当聚簇索引遍历完毕，并全部插入到新索引之后，重放Row Log中的记录修改，使得新索引与聚簇索引记录达到一致状态。

另外，**不是所有的alert操作都是Online DDL的，比如增加全文索引就不是Online的。**



##### 几种重建表的语句

- alert table t engine=InnoDB: 流程就是上面说的，使用Online DDL方式重建表，重建过程中允许数据的更新，更新被写入到row log中，重建完成后使用row log进行逻辑同步，并且DDL获取到的MDL写锁会退化成 MDL读锁，保证Online，并且不允许其他线程进行DDL。
- analyze table t: 这个语句不是重建表，只是对表索引信息进行重新统计，防止统计失误而选错索引。并没有修改数据，重新统计过程中加了MDL读锁。
- optimize table t: 相当于 recreate + analyze 即重建表并且重新统计索引信息。



##### 一个问题：“想要收缩表空间，但是结果空间却变大了”，这是为啥？

1. 一个表t文件为1TB
2. 对这个表执行 alert table t engine = InnoDB;
3. 发现执行后，空间变大为 1.01TB，还变大了一点，这是为什么？

原因在于：这个表原来就是很紧凑的状态，重新建表的过程中，innodb会给数据页一些预留空间，导致文件变大。另外可能是Online DDL过程中存在数据更新，还可能导致空洞。