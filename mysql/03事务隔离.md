### 事务、事务隔离

##### 事务

事务简单来说，就是一组SQL语句，要么全部执行，要么都不执行，是一个原子性操作。

事务是存储引擎层实现的，但是有些存储引擎不会支持事务，不如MyISAM引擎就不支持事务。

##### 事务的隔离级别

事务的隔离级别分为：

1. 读未提交

    当前事务没有提交的修改，也可以被其它事务读到。

2. 读已提交

    当前事务已经提交的修改，才可以被其它事务读到。

3. 可重复读

    当前事务已经提交的修改，也不可以被其它事务读到。

4. 串行化

    事务完全串行，对于同一行记录，会有读写锁，没有获取到锁的事务线程会阻塞。

##### 事务的隔离是如何实现的？

事务执行过程中，会以一个创建的视图为标准。

具体来说，读未提交直接返回最新的数据，没有视图的概念；读已提交会在每次SQL语句执行的时候创建视图；可重复读会在事务启动的时候创建；串行化则是读加读锁，写加写锁，避免事务并发访问同一个数据行。

SQL中一条记录可能会存在多个基于视图的不同版本，这就是MVCC（多版本并发控制）。

每个事务进行的过程中，不仅会记录redo log，还会记录undo log，用于回滚。

##### undo log什么时候删除？

不需要的时候删除，当undo log之前没有更早的视图的时候，就不需要使用undo log回滚。

##### 长事务带来的内存问题和CPU资源占用

长事务会导致长时间存在的视图，并且每一条语句都需要undo log记录实现回滚，所以会占用大量空间；

另外，长事务会导致死锁检测频繁，事务中每条语句都需要进行死锁检测，消耗大量CPU资源；

##### 事务的启动方式

1. 显示启动事务：begin;start transaction，之后使用commit提交，rollback回滚；
2. set autocommit=0，关闭自动提交，也就是说，平时一条SQL语句都被当作一个事务处理，关闭自动提交后，需要手动commit提交才会执行SQL语句。
3. 建议使用set autocommit=1，显示启动事务，另外，如果大量事务执行，可以使用commit work and chain管道操作，提交后自动开启下一个事务，避免一次begin开启事务的交互。

##### 查询长事务

information_schema库中的innodb_trx表中查询trx_started字段，可以查到事务的开启时间。



#### 事务的四大特征及实现原理

**⑴ 原子性（Atomicity）**　

​		原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

**⑵ 一致性（Consistency）**　　

​		一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

**⑶ 隔离性（Isolation）**　　

​		隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。　　

​		即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。　　

​		关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。

**⑷ 持久性（Durability）**　

​		持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。　　

​		例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。



以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果**不考虑事务的隔离性，会发生的几种问题**：

**1，脏读**　　

脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下update account set money=money+100 where name=’B’; (此时A通知B)
update account set money=money - 100 where name=’A’;　　

当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。

**2，不可重复读**　　

不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。　　

例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。　　

**不可重复读和脏读的区别**是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。　　

在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……

**3，虚读(幻读)**　　

幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。　　

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 　

现在来看看MySQL数据库为我们提供的四种隔离级别：　

① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。　　

③ Read committed (读已提交)：可避免脏读的发生。　　

④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 　

以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。　　

在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。



##### **关键总结：**

**原子性 是通过 undo log保证的**，在进行事务提交时，会将执行的操作以相反的方式记录在undo log中，在 执行回滚 或者 执行失败时 通过读取undo log文件将 数据回滚到 上次原子性数据。

**持久性 是通过 redo log保证的**，我们知道，在进行 io时，并不会之间 将数据写到硬盘上，而是 存在 用户态（Sql server）和 内核态（OS Buffer）之间的复制，最后由OS完成硬盘读写，持久化是指将 数据持久化存储在硬盘上，这个过程中 有可能 在 OS Buffer中的数据丢失，于是，其实sql server除了复制到OS Buffer，还会保存一个 redo log文件，用于在 OS Buffer数据丢失时redo重新进行持久化存储。

**隔离性** 是指不同的事务之间应该存在隔离，互相不影响，不能感受到别人的存在。则是通过**多版本视图并发控制MVCC**实现的。



**事务隔离有4种等级**，分别是 **读已提交、读未提交、可重复读 和 序列化**。

这4种隔离等级总结起来，可以看成以 事务Commit 为分界，其他事务对 commit 前和commit后的数据的感知能力（或者叫会不会收到影响）。

**读未提交**：其他事务能够读到 该事务 未提交的 数据。会造成 所谓的 脏读、不可重复读、幻读。

**读已提交**：其他事务只能读到 该事务 已提交的 数据，不会产生 脏读，但 存在 不可重复读 和 幻读。

**可重复读**：其他事务不管在 该事务提交前还是提交后，都会读到同样的原生数据。不存在脏读、不可重复读，但有 幻读。

**序列化**：事务之间完全隔离，看起来 并发的事务就像是 串行一样，脏读、不可重复读、幻读 都不存在。

上述其实已经讲了 不同隔离机制带来的 3 种问题，分别是 脏读、不可重复读 和 幻读。

**下面强调（重复一下）。记忆上来说，可以 以commit为分界线。**

**脏读**：指 其他 事务会话过程 读到了 该事务 commit 之前的 数据（或者更改）。

**不可重复读**：指 其他 事务会话 能读到 commit之后 的数据，导致 其他事务 读到commit之前的数据，再次重复读 则可能读到 commit之后的数据。

**幻读**：幻读和不可重复读差不多，区别在于 不可重复读 是在 查询场景，而 幻读 则是在 插入场景，也就是说，比如，其他事务 读到了 insert commit之后的数据，导致可能再次insert失败。