### 事务、事务隔离

##### 事务

事务简单来说，就是一组SQL语句，要么全部执行，要么都不执行，是一个原子性操作。

事务是存储引擎层实现的，但是有些存储引擎不会支持事务，不如MyISAM引擎就不支持事务。

##### 事务的隔离级别

事务的隔离级别分为：

1. 读未提交

    当前事务没有提交的修改，也可以被其它事务读到。

2. 读已提交

    当前事务已经提交的修改，才可以被其它事务读到。

3. 可重复读

    当前事务已经提交的修改，也不可以被其它事务读到。

4. 串行化

    事务完全串行，对于同一行记录，会有读写锁，没有获取到锁的事务线程会阻塞。

##### 事务的隔离是如何实现的？

事务执行过程中，会以一个创建的视图为标准。

具体来说，读未提交直接返回最新的数据，没有视图的概念；读已提交会在每次SQL语句执行的时候创建视图；可重复读会在事务启动的时候创建；串行化则是读加读锁，写加写锁，避免事务并发访问同一个数据行。

SQL中一条记录可能会存在多个基于视图的不同版本，这就是MVCC（多版本并发控制）。

每个事务进行的过程中，不仅会记录redo log，还会记录undo log，用于回滚。

##### undo log什么时候删除？

不需要的时候删除，当undo log之前没有更早的视图的时候，就不需要使用undo log回滚。

##### 长事务带来的内存问题和CPU资源占用

长事务会导致长时间存在的视图，并且每一条语句都需要undo log记录实现回滚，所以会占用大量空间；

另外，长事务会导致死锁检测频繁，事务中每条语句都需要进行死锁检测，消耗大量CPU资源；

##### 事务的启动方式

1. 显示启动事务：begin;start transaction，之后使用commit提交，rollback回滚；
2. set autocommit=0，关闭自动提交，也就是说，平时一条SQL语句都被当作一个事务处理，关闭自动提交后，需要手动commit提交才会执行SQL语句。
3. 建议使用set autocommit=1，显示启动事务，另外，如果大量事务执行，可以使用commit work and chain管道操作，提交后自动开启下一个事务，避免一次begin开启事务的交互。

##### 查询长事务

information_schema库中的innodb_trx表中查询trx_started字段，可以查到事务的开启时间。

