### 行锁

顾名思义，在数据行上加的锁，需要注意的是，全局锁和表锁是 server层面实现的，而 行锁是引擎层实现的，所以不是所有的存储引擎都支持行锁，比如MYISAM就不支持行锁，只能使用表锁来实现并发控制，而表锁的问题就在于锁粒度太大，同一时间只有一个更新线程可以在这个表上执行，这降低了并发度。所以这也是 使用 INNODB 代替 MYISAM 的原因之一。

##### 两阶段锁

在INNODB事务中，行锁的释放不是在执行完这条访问行的语句之后，而是整个事务结束后才会释放所有持有的行锁。

比如下图中，A得到ID=1和ID=2的行锁，虽然之后A事务中执行完了ID=1这行的更新，但没有释放ID=1的行锁，B因为需要ID=1的行锁而阻塞，只有等待事务A commit之后，B事务才能得到ID=1行锁。

![Image](C:\Users\admin\AppData\Local\Temp\chrome_drag10144_27953\Image.png)

所以，我们应该把并发度较高的 语句，或者说并发度高的行访问，放在事务的靠后部分，减少对 高并发行数据锁 的持有时间，增大并发效率。

##### 死锁和死锁检测

**死锁**：事务之间都在等待对方持有的锁。发生锁资源请求的死循环。

***解决死锁的方法***

- 设置获取锁超时时间，当获取锁超时后线程直接退出。缺点在于 锁超时时间不能确定，超时时间设置太长则会阻塞其它线程太久，设置太短则可能会误伤其它正常等待锁的线程。*innodb_lock_wait_timeout*
- 死锁检测，死锁检测可以开启自动进行，检测到死锁后进行事务的回滚，让其它事务正常进行。*innodb_deadlock_detect = on*

**死锁检测**：在事务中，每条对于共享行数据（可能造成死锁的行）的访问，都需要进行死锁检测，死锁检测需要遍历锁链，检测是否存在锁请求的死循环，这将会消耗大量的CPU资源，**这也是长事务消耗CPU资源的原因。**

*提问：如何解决对热点行更新导致的性能问题？*

关键就在于死锁检测，大量对于并发资源的访问需要进行死锁检测，消耗CPU资源，

我们一是可以之间关闭死锁检测，那么就可能会导致大量的死锁线程。

二是可以控制并发度，减少死锁检测的次数，控制对于同一行最多只有10个线程在更新。