#### 索引

索引是MySQL或者说存储引擎的关键，它是数据库使用来能大幅度提交SQL查询效率的关键。索引是存储引擎层实现的，不同的存储引擎可能提供不同的索引实现，也可能不支持索引，innoDB索引是使用B+树实现的，MyISAM索引是使用hash数组实现的。

##### 索引数据结构

下面讨论索引的数据结构，为什么innoDB索引是使用B+树，而不是其它的数据结构。先看看可以使用哪些数据结构。

- *hash表，hash表可以用吗，有哪些问题？*

- 首先，hash会带来hash碰撞的问题，查询效率降低。其次，hash表存放是无序的，进行范围查找的时候需要全表扫描，效率太低。

- *有序数组*

- 有序数组对于范围查找效率高，但是插入需要移动大量数组元素，效率不高。

- *二叉树*

- 二叉树的问题在于会退化成链表，同样插入需要移动大量元素，并且不是有序的，不支持范围查询。

- *平衡二叉树*

- 平衡二叉树需要大量的平衡旋转操作。

- *红黑树*

- 红黑树虽然平衡操作少了，但还是树太深了，树太深了就意味者 磁盘IO随机访问数据页的次数增加，指针寻址的次数增加，我们希望减少 磁盘IO访问数据页的次数。

- *B树*

- B树是这样的，是一个N叉树，树节点中存放 key， 指向子节点的指针，以及数据value，而且key是有序的，是一个范围，像跳表一样。在innoDB存储引擎中，key就是索引的值，value就是对应的数据行数据。B树的问题还是树太深了，或者说相同树深度存放的数据量比较少。

- *B+树*

- B+树是在B树上的改进，它是这样，B+树只使用叶子节点存放数据行value，非叶子节点存放 索引key，指向子节点的指针point，这样做的好处是：因为每一个节点或者说数据块的大小是固定的，InnoDB中是16KB，这是因为 OS磁盘IO都是以数据页为最小单位的，是4KB，那么这样只存放 key和point，就可以增大N叉树的N，也就是分支数量，极大的提高存储的数据量。*另外，point是6bytes。*

- 而且，B+树的叶子节点是使用双向链表，提高了查询效率。

    

##### 聚簇索引和非聚簇索引

简单说，非聚簇索引就是索引和行数据不是存放在一起的，聚簇索引则是索引和数据是存放在一起的。

innodb有且只有一个聚簇索引，可以有多个非聚簇索引，只能有一个的原因很简单，聚簇需要index和data放在一起，多个就存在多个data的副本，太冗余。

如果有主键，主键就是聚簇索引，如果没有主键，那么就是第一个唯一非空索引，如果还没有，innodb会自己生成隐藏的rowid作为聚簇索引。



##### 索引的优化（索引规则）

- 回表
    - 因为非聚簇索引上面没有存放数据data，所以当非聚簇索引树上没有需要的数据时，就会根据非聚簇索引树上的value，也就是聚簇索引的key，回到聚簇索引树上查询需要的数据。很明显回表效率降低了。
- 索引覆盖
    - 索引覆盖，就是说非聚簇索引树上可以查到需要的数据，不需要回表。
- 最左匹配
    - 对于联合索引而言，比如(a, b)联合索引，使用a或者使用a and b都能命中索引，走索引查询。
    - 这其实就是因为联合索引在索引树上的结构决定了，现在存在(a, b)联合索引，索引树中的key就是两个，而走索引查询的时候（或者说索引树建立的时候），需要比较索引的大小排序，那么如果a是绝对有序的，b就是无序的，只有在a相同的时候，b才是有序的。所以如果只有b，就不能走索引树，而是全表扫描，扫描叶子节点的双向链表。
- 索引下推
    - 对于联合索引而言，之前没有索引下推的时候，只会根据最左匹配的索引在非聚簇树上查到主索引的key，然后每次都回表，在主索引树上过滤掉其它索引不符合的数据，返回给服务层。而有了索引下推的优化，现在就是直接在 非聚簇索引树上过滤掉所有索引不符合的数据，然后才根据主索引key回表。
    - 索引下推减少了回表次数，提高效率。

```sql
select from t where name like "张%" and age = 10; // primary key ID, index name , index age
```



![Image](C:\Users\admin\AppData\Local\Temp\chrome_drag10144_6839\Image.png)

