### 备库延迟高？备库的并行复制能力！

​	前面我们说了一些会影响主备延迟的场景，在这些场景中，无论是 偶发的 查询压力，还是备份，对备库的延迟影响一般都是 分钟级别的，也就是说，一般 备库的 relay log 都会被正常的消费掉。

​	但是，如果备库消费 relay log 的速度 一直慢于 主库生产 bin log 的速度，那么 备库就会一直出处于 延迟状态，而最终可能导致 备库延迟很高，甚至达到 小时级别。

​	而这，可能就是因为 备库中消费 relay log 的是一个单线程sql_thread。也就是下图中的slave中的sql_thread。

![img](https://static001.geekbang.org/resource/image/1a/ef/1a85a3bac30a32438bfd8862e5a34eef.png)

​	在 MySQL 5.6 前，sql_thread 都是单线程实现，中间经历了几个版本。总体来说，都是将一个线程sql_thread拆分成多个线程，将多个 relay log 分发给不同的线程执行。

![img](https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png)

而这样，需要考虑 两个问题：

1. 同一个事务中的两个log记录，能不能交给不同的线程执行？

不能，这样会破坏事务的原子性，可能可以访问到一个事务中间状态的数据。

2. 两个事务对于同一行数据的log记录，能不能交给不同的线程执行？

不能，这样可能会照常log记录执行顺序不一致，导致数据不一致。



考虑上面两个问题，然后，怎么实现？

1. 按表分发：

如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。

每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：

如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;

如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；

如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。

这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。

2. 按行分发：

    要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求 binlog 格式必须是 row。

    相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。

    - 要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；

    - 表必须有主键；

    - 不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。

MySQL 5.6 中的并行复制策略

官方 MySQL5.6 版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的 hash 表里，key 就是数据库名。

MariaDB 的并行复制策略

。。。

MySQL 5.7 的并行复制策略

。。。