### 幻读是什么？幻读有什么问题？

##### 示例

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

​	这个表除了主键id外，还加了一个索引c，初始化语句插入了6行数据。

​	先考虑一个问题：下面的语句是怎么加锁的？锁又是什么时候释放的?

```sql
begin;
select * from t where d = 5 for update;
commit;
```

​	这个语句会命中 d = 5 这一行，对应主键为id=5，因此 select 执行完成后，id=5这一行会加一个写锁，并且由于双阶段锁协议，这个行锁会在commit的时候释放。

但是，**由于 字段d 上没有索引，这条查询语句会走全表扫描，那么，其它被扫描的，但是不满足条件的 5 行记录，会不会被加锁呢？**

##### 幻读是什么？

​	下面来分析，如果只在 id = 5 这一行上加锁，而其它行不加锁的话会有什么问题。

假设下面这个场景：

![img](https://static001.geekbang.org/resource/image/5b/8b/5bc506e5884d21844126d26bbe6fa68b.png)

Session A 中执行了3次查询，分别是 Q1 Q2 Q3，查询所有 d = 5 的行，而且使用的是 for update 当前读，并且加上写锁。

但最后，

Q1 只返回 id = 5这一行；

在 T2 时刻 Session B 把 id=0 这一行的 d 值改为了5，所以 Q2 查出来的是 id=0和id=5两行。

Session C 在 T4时又插入了 一条新行(1, 1, 5)，因此 T5 时刻的Q3查出来的是id=0,id=1,id=5 这三行。

其中，Q3读到的 id=1 这一行的现象，被称为 "**幻读**"。

​	也就是说，**幻读指的是在一个事务中，前后两次查询同一个范围内的时候，后一次查询看到了前一次查询没有看到的行。** 

​	这和 不可重复读 有所区别，相同点在于 不可重复读 和 幻读 都是在同一个事务中两次查询的结果不同，但是 不可重复读 针对的是 更新操作，也就是其它事务的更新导致同一行数据被修改，而 幻读 则是对于多条数据而言的，即 其它事务 插入了一条新记录，导致 本事务的新的范围查询中 看到了 这条新记录，而原范围查询中并没有。

需要说明一下：

1. 在可重复读隔离级别下，普通的查询是快照读，是不会看到其它事务插入的数据的，因此，幻读在 “当前读” 下才会出现。
2. 上面 Session B 的修改结果，被 Session A 之后的 select 语句用 当前读 看到，不能称为 幻读，幻读 专指看到了新插入的行。



##### 幻读有什么问题？

在假设 只在 id = 5 这一行上加锁会产生什么问题？

1. 首先是语义上的，比如Session A在T1时刻声明将所有d=5的行锁住，但现在只是锁住了id=5 d=5的行。
2. 更关键的是 **数据一致性问题**，一致性不仅仅是数据一致，而且是 **日志与数据的逻辑一致。**

而在这里，则可能会导致 日志与数据 的逻辑不一致，也就是说 使用 bin log 得到的数据 和 当前数据不一致。

**所以，在 select \* from t where d = 5 for update 这条语句执行过程中，会将扫描的所有行都加上行锁。**

但是这依然没有解决 幻读 的问题，也就是说，Session C 的插入操作 依然 会被 其它的事务 读到。

这是因为，新插入的数据行不会被上锁，**也就是说，即使对所有的记录都加上锁，还是阻止不了新记录的插入。**



##### 如何解决幻读？

​	现在我们知道了，幻读产生的原因在于 **行锁只能锁住行，并不能阻止新纪录的插入。**

​	于是，为了解决幻读问题，InnoDB只好引入新的锁，也就是 **间隙锁 Gap Lock**。

**间隙锁**：也就是说锁的是行记录之间的间隙，比如6行记录，就产生7个Gap Lock。

![img](https://static001.geekbang.org/resource/image/e7/61/e7f7ca0d3dab2f48c588d714ee3ac861.png)

​	所以，当执行 select \* from t where d=5 for update 的时候，就不只是将所有扫描记录上锁，并且将这些记录的间隙上锁。这样就确保了 不能插入新的记录。

​	强调一下的是：间隙锁并不像行锁一样，锁之间不会存在冲突，也就是说，间隙锁冲突的是向间隙中插入新记录，而如果多个事务都加间隙锁，都为了达到同一个目的，则是可以的。

**next-key lock**

​	间隙锁和行锁合称 next-key lock，每个next-key lock 都是前开后闭区间。比如我们上面的例子，使用 select \* from t for update 把整个表所有记录锁起来，就形成了 7 个 next-key lock，(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。

​	supremum：为了满足 前开后闭，InnoDB 给每个索引都加了 一个不存在的最大值 supremum。



**间隙锁 和 next-key lock 的问题**

​	对我们这个例子来说，next-key lock 可能会出现的问题：

​	比如：任意锁住一行，如果这一行不存在则插入，如果存在则更新它的数据。

```sql
begin;
select * from t where id=N for update;

/*如果行不存在*/
insert into t values(N,N,N);
/*如果行存在*/
update t set d=N set id=N;

commit;
```

可能会问：这不是可以使用 insert ... on duplicate key update 解决吗？但是，如果存在多个唯一键，这个方法是不能实现上面的需求的，原因后面章节提到。

​	这个例子的问题在：**一旦出现并发情况，就会出现死锁。**

如下：

![img](https://static001.geekbang.org/resource/image/df/be/df37bf0bb9f85ea59f0540e24eb6bcbe.png)

可以发现，不需要用到后面的update语句，就会产生死锁。过程如下：

1. Session A开启事务，执行 select 语句，该语句由于该行不存在，所以会加上间隙锁(5, 10)；
2. Session B 开启事务，执行 select 语句，同样的也加上间隙锁。
3. Session B 执行 insert 语句，但被 Session A 间隙锁 挡住了，只好阻塞 等待 (5, 10) 间隙锁的释放。
4. Session A 执行 insert 语句，但被 Session B 间隙锁 挡住了，从而产生死锁。

