### 事务实现原理

我们之前知道，MVCC多版本控制是基于事务创建的一致性视图的，在可重复读隔离级别下，在事务启动的时候会创建一致性视图，后续执行过程中都以这个视图为准，其它事务的修改对于该事务来说不可见。

MySQL中，有两个视图的概念：

1 view，一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。

2 InnoDB在实现MVCC时用到的一致性视图，用于支持RC(Read Committed，读提交)和RR(Repeatable Read，可重复读)隔离级别。

**视图快照在MVCC中如何实现**

快照是对于整库的，而我们不可能拷贝出整个数据库。那是怎么实现的？

对于每一个事务都有一个唯一的事务ID(transaction id)，而每行数据也是有多个版本的，每次事务更新数据的时候，都会生成一个新的数据版本，并且将该事务的transaction id赋予这个数据版本，记为row trx_id，也就是说，数据表中的一行数据，可能存在多个数据版本，每个版本都有自己的row trx_id。但是并不会保存所有的数据版本，而是根据当前数据版本数据，和undo log进行版本的回滚，找到对应的数据版本，也就是对应的视图。

![img](https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png)

**在实现上**

InnoDB对于每个事务，维护了一个数组，存放这个事务启动时，当前活跃的所有事务的ID(也就是启动但没有提交的事务)。

数组中所有活跃事务的ID的最小值(也就是 启动时的最早启动的活跃事务的ID) 称为 低水位。

当前系统中已经创建的事务的ID+1 称为 高水位。

事务通过这个 数组 和 高水位 与 当前数据版本的row trx_id(也就是对应事务id) 来实现 视图，也就是保证一致性、隔离性。

如果当前数据版本的id，小于低水位，则这个版本的数据对于当前事务创建之前的事务修改的，是 可见的。

如果当前数据版本的id，高于高水位，则这个版本的数据是当前事务创建之后的事务修改的，是 不可见的。

如果当前数据版本的id，在低水位和高水位之间，则还需要判断 当前事务创建时活跃事务中是否存在 这个事务，即需要判断这个id是否存在于 活跃事务id数组中，只有不在数组中，才是可见的。（在数组中，说明 当前数据对应的事务还是 活跃事务，还没有提交）。

如果按照时间线梳理一下：

如果当前数据版本对应的事务 还没有提交，则不可见。

如果当前数据版本对应的事务 已经提交(即不在事务维护的活跃事务数组中)，但是是在 是在事务创建之后提交的（即高于高水位），则不可见。

如果当前数据版本对应的事务 已经提交(即不在事务维护的活跃事务数组中)，而且是在 是在事务创建之前提交的（即低于低水位），则可见。

如果当前数据版本不可见，则会使用undo log进行回滚，直到满足可见性（即隔离性）。



**对于视图中的update的当前读问题**

一致性视图中的select读是一般读，也就是一致性读，读到视图创建时的数据。而对于update，则是先读后写，这里的读则是当前读，也就是说会读最新的数据，然后修改。

