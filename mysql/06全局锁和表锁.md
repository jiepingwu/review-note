## 全局锁和表锁

同样的，数据库中的锁也是为了解决并发访问数据时的安全性。

数据库中的锁按粒度可以分为 全局锁、表锁 和 行锁。这里讲 全局锁 和 表锁，行锁下一站。

### 全局锁

**全局锁是对整个数据库实例加锁，全局锁会使整个数据库处于 只读 状态，其它任何线程的 增删改 DML 和 修改表结构DLL 以及 事务中的更新，都会被阻塞。**

##### 全局锁的典型应用场景

使用全局锁使数据库处于只读状态，进行**全库备份**，整个数据库都处于只读状态。

这样不好，原因在于，整个库都是只读状态，那么主库备份期间 不能更新数据，业务停摆。如果在从库上备份，那么就不能同步 主库传来的 bin log，导致主从延迟。

*那么怎么做比较好呢？*

可以利用 事务的唯一性视图，使备份操作在同一个不变的视图上进行。官方自带备份工具mysqldump中使用 -single -transaction时，就会在备份时启动一个事务，并且使用事务启动时创建的唯一性视图。

但是，由于这是基于事务的解决方案，所以对于不支持事务的存储引擎，比如MYISAM，就不是使用事务的一致性视图完成全库备份，而是只能使用 全局锁。

*那 set global readonly = true呢，设置全局参数 readonly。跟使用全局锁有什么区别？*

主要区别在于，readonly没有异常处理机制，客户端发送异常断开时，不会恢复，数据库一直保持readonly状态。而全局锁会处理异常，在发生异常后，恢复到可以正常更新的状态。

### 表锁

表锁分为两种，一是表锁，二是元数据锁metadata lock。

**表锁**

表锁是读共享，写互斥，读写互斥，即获取到共享读锁可以同时读 ，而只有获取到了写锁的线程才能读写。

语法为 lock tables ... read/write。

表锁的粒度还是过大，当使用的存储引擎可以支持 行锁的时候，还是使用行锁比较好。

**元数据锁metadata lock**

元数据锁MDL是针对 表的metadata而言的，也就是针对表的结构数据。

MDL是在我们访问一个表的时候自动加上的，目的是为了 阻止 在读写数据的过程中，表结构数据被修改了。

具体来说，在进行DML增删改查的时候，加上MDL 读锁，而在 进行 DLL表结构修改的时候，加上MDL 写锁，也就是说允许并发进行DML，而只有一个线程可以进行DLL。这里MDL的读锁共享，写锁互斥，读写锁互斥。

**对于MDL，虽然它是自动加上的，我们不需要管，但是也可能出现问题。**

MDL有一个关键，就是它请求锁的时候维护一个队列，队列中的写锁拥有比读锁更高的优先级，也就是说当有一个MDL写锁发生阻塞的时候，除了当前的线程会被阻塞之外，后续的其它操作都会被阻塞，这就可能导致大量的客户端连接阻塞，如果连接有重试，那么将会撑满整个数据库连接池。

所以我们应该避免长事务长时间霸占MDL锁，等待长事务执行完之后再进行DLL或者直接kill掉长事务。

还可以给DLL操作设置超时等待时间，阻塞的时候阻塞一段时间，然后可以继续执行后面的业务语句。