### COUNT(\*)很慢，我该怎么办？

我们会需要计算一张表的行数，通常使用 **select count(*) from t** 查询。

但是，随着记录越来越多，你发现count(\*)执行速度越来越慢，你会觉得，为什么MySQL不在插入删除的时候记录一个 count 总数，我们直接拿这个总数不久行了吗，这不是o(1)的吗，为什么每次都要count(\*)一下？



#### count(\*)的实现方式

对于不同的 MySQL 存储引擎，count(\*)的实现方式不同。

- MyISAM中：会记录count数量，每次直接o(1)地拿到这个值即可。一个表的总行数记录在了磁盘上。
- InnoDB中：就很麻烦，不会记录count数量在磁盘中，而是每次都需要一行行扫描然后计数。

*注意：这里说的是不带过滤where条件的count，如果有条件，可想而知MyISAM只有总数是不行的，也需要扫描。*

##### 为什么InnoDB不记录总行数，而是在count时需要一行行扫描?

因为 **需要保证MVCC，也就是说每行数据可能属于不同的视图，需要扫描每一行，判断行是否对于当前视图可见。**

InnoDB还是做了优化的，比如，主键索引数上的叶子节点保存的时数据，而普通索引保存的是主键索引，所以普通索引树会比主键索引树小很多，对于 count(\*)这样的操作，遍历主键索引树或者普通索引树的结果是一样的。所以，MySQL优化器会 **寻找最小的索引树** 来遍历得到结果。

另外，**show table status 中有一个 TABLE_ROWS 展示当前表有多少行，但是！这个数据不是正确的，像索引统计值一样，这个数据也是通过统计估算的，官方表示误差可能达到40%-50%。**

**小结一下**

- MyISAM 表虽然count(\*)很快，记录了行数，但是不支持事务。
- InnoDB 表由于需要支持MVCC，所以count(\*)时需要遍历每一行判断是否对于当前视图可见，效率不高。
- show table status中的TABLE_ROWS记录是估算值，不准确。



##### 如果一个表，我们需要经常查询表的行数，要怎么办？

InnoDB中的count(\*)因为要扫描全表，很慢，那该怎么办？

**基本思路：找到一个地方，把记录表的行数存放起来。**

方式1：使用redis缓存保存这个行数。

​	**问题1：**这种方式可能会造成**数据的丢失**，缓存不可能一直保存在内存中，我们需要将其持久化，后续在从磁盘读取。但是还是会产生数据丢失，比如：在更新了redis缓存后，redis异常重启，这个时候还没有持久化到磁盘中，redis重启后从磁盘读取的数据中就丢失了这个更新。

​	解决方式：redis异常重启后，不从磁盘中读取数据，而是再进行一次count(\*)从数据库中得到查询值。

​	**问题2：**除了数据的丢失，使用缓存系统保存计数，还可能造成**数据逻辑不准确**的问题。

​	为什么？

​	从宏观的角度来看，这种分布式系统可能会带来 并发情况下的数据不一致。这就是说，我们不能保证这样分别在两个系统中的 update data 和 update count 的原子性，也就是说，可能在 update data 和 update count 之间，插入了一个操作，这个操作就只能看到 update data 但不能看到 update count。导致该操作得到的结果data 和 data count不一致。



方式2：使用数据库保存计数。

​	redis缓存系统保存有什么问题？

​		上面看到了，由于是不同的系统，我们无法保证redis中的count更新和 MySQL中的data更新是原子性操作，并发情况下存在数据不一致的问题。

那么我们就保存在同一个系统中，能使用数据库保证count和data的更新原子性吗？

- 首先我们来看 数据丢失 的问题，我们知道 MySQL异常重启是可以通过 redo log恢复的。解决了数据丢失的问题。
- 那么，数据逻辑不准确呢？

​		我们要解决的，就是count和data的更新不是原子性的问题，我们明显可以使用innodb的事务来实现这两个操作的原子性，count和data的更新在同一个事务中。那么，在事务提交之前，其他线程会话就不可能读到count或者data的其中之一的单个更新。



#### 不同的count

count(\*) 和 count(主键id) 和 count(1)：返回满足条件的结果集的总行数。

count(字段)：返回满足条件的结果集中，字段不为null的总个数。



- count(主键id)：innodb遍历整个表，将每一行的id值取出来，返回给server层，server判断是id是不可能为null的，就按行累加。
- count(1)：innodb遍历整个表，但不会取值，server对于每一行都放一个数字"1"进去，按行累加。
- count(字段)：如果字段not null，按行累加；如果字段允许为null，那么需要把值取出来判断一下不是null才累加。
- count(\*)：count * 比较特别，不会把全部的值取出来，而且*也肯定不是null，之间按行累加。

可以发现：count(主键id) 相比 count(1) 来说会比较慢，因为需要返回id值给server，从innodb返回 id值还需要解析数据行，以及拷贝字段值。

可能会问：为什么count(id)不像count(*)一样做优化呢，id肯定也是not null的。因为MySQL已经对count(\*)优化了，没必要再优化count(id)。

效率对比：count(*) ~= count(1) > count(主键id) > count(字段)，尽量使用count(\*)。



**一个问题：对于上面说的使用 count表来保证count计数，那么从并发的角度考虑，是应该先更新count还是先更新data？**

​	我们知道，对于并发度高的操作应该放在事务的后面，这里就是应该先update data 再 update count，因为update data只需要行数和间隙锁，而update count 需要count表的写锁，count表写锁会阻塞其他线程对于该count表的更新操作。

