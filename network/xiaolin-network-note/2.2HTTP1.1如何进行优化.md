### HTTP1.1如何优化

![image-20210621192231509](..\..\references-figures\image-20210621192231509.png)

如何对HTTP1.1进行优化？

我们第一时间想到的，可能就是 使用 长连接来代替 HTTP1.1中的短连接，避免大量的创建和关闭TCP连接带来的资源消耗。

还有其它的思路，我们要优化一个传输协议，可以从以下方面考虑：

1. 如何避免发送HTTP请求？
2. 如何减少HTTP请求次数？
3. 如何减少HTTP请求数据大小？

#### 如何避免发送HTTP请求？

什么叫避免发送HTTP请求？就是能不发我们就不发。

对于一些每次请求得到的数据都是一样的，或者请求次数很频繁的数据，我们就可以把这对 请求-响应 的数据都 **缓存在本地，下次直接读取本地的数据，而不需要通过网络去服务器获取。**

所以，避免发送HTTP请求的方法就是使用 本地缓存，HTTP协议中头部有许多针对缓存的字段。

客户端第一次请求时 将 请求url 和 响应资源 作为 key-value 保存在本地上，第二次就可以直接使用url为key在本地获取资源。

用到缓存，就需要考虑一个问题：缓存更新。

而HTTP也考虑到了，所以，在 **服务器发送HTTP响应时，会设置一个缓存超时时间，并且放入到response header中，这样客户端在查看响应头部信息时，如果发现了缓存是过期的，则会重新发送请求。**

另外，如果 缓存超时后重新请求时，如果服务器资源没有变更，那么如果服务器不需要发送这个资源回去，就能提高性能。

HTTP是怎么实现的呢？

客户端在重新发送请求时，在**请求的 Etag头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源**。

服务端对比 这个请求中的摘要 和 本地资源摘要 是否一致，如果不一致说明资源变动，需要响应新资源。

如果摘要一致，说明资源没有变动，那么 服务器就 **只返回不含有包体的 304 Not Modified，说明缓存资源仍然有效。**



##### 如何减少HTTP请求次数？

1. 减少重定向请求。
2. 合并请求。（将多个小文件资源的请求合并为一个大文件，比如大量图片合并为一张图片的请求，将js，css资源打包请求）
3. 延迟发送请求。（当前不需要的资源，不需要也获取过来，按照按需获取的方式，只获取当前用户看到的页面资源，当用户下滑页面时，再向服务器获取接下来的资源。）



##### 如何减少 HTTP 响应数据的大小？

对响应资源进行压缩：

1. 无损压缩
2. 有损压缩



![image-20210621200709666](..\..\references-figures\image-20210621200709666.png)

