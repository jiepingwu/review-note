### HTTPS RSA 密钥交换算法

##### 前言

HTTP 是明文传输的不安全的协议，会产生以下问题：

1. 被窃取通信信息。(信息通过加密，第三方无法窃取)
2. 被篡改通信信息。(校验传输过程中信息是否被篡改)
3. 被冒充服务器。(验证服务器身份证书)

**HTTPS 通过在 HTTP 和 TCP 之间 增加了一层 SSL\TLS协议层 来保证安全性**。



##### RSA 非对称加密算法

而为了效率性能方面考虑，通信时使用的是 对称加密算法，但是 对称加密密钥 是不能泄漏的，所以，为了保证会话密钥的安全，使用 非对称加密算法 来进行保护 对称加密密钥的协商过程，SSL中经常使用的就是 RSA 密钥交换算法。



##### TLS 四次握手过程

HTTPS 经过 TCP 的 3次握手之后，还需要 进行SSL 的握手过程，如下：

**TLS 第一次握手**

Client Hello：

1. 发送客户端使用的 **SSL 版本号**
2. **支持的密码套件列表**
3. 一个随机数**Client Random**。

***密码套件列表***

密码套件列表包含了 需要的可用的加密算法列表，比如：

- 密钥协商算法，如 RSA、DHE、ECDHE
- 签名算法 如 RSA
- 握手后通信使用的对称加密算法 AES
- 摘要算法 SHAXXX 等



**TLS 第二次握手**

Server Hello：当服务端收到Client Hello后

1. **确认TLS版本号**是否支持
2. 从密码套件列表中**选择一个密码套件**
3. 一个随机数**Server Random**
4. **Server Certificate**：为了证明服务器身份，发送Certificate消息，含有**数字证书**。
5. **Server Hello Done**：**告知Client，Hello消息结束**。

###### ***Certificate 数字证书***

为了证明服务端的身份安全，Server Hello过程中会将服务器的数字证书发送给客户端。

这个数字证书是怎么生成的？客户端又是怎样验证数字证书的可靠性的？

1. 数字证书的内容
    - **服务端RSA的公钥**
    - 服务端信息
    - CA信息
    - **CA签名和使用的算法**
    - 过期时间
    - ...

2. 数字证书如何产生？

数字证书由CA证书认证机构颁发，为了保证服务器的公钥的可信，服务端证书都由 CA 签名，签名可以避免中间人在获取证书时对证书内容进行篡改。

**数字证书的签发流程**

CA将持有者的公钥、用途、颁发者、有效时间等信息打包，然后计算出一个CA Hash Code。

使用CA私钥对该Hash Code进行加密，生成数字签名 Certificate Signature。

将数字签名加在该文件证书上，形成数字证书。

**客户端验证过程**

客户端使用相同的Hash算法计算出该证书的Hash值，Client Hash Code.

使用CA公钥解密 数字签名 Certificate Signature，得到CA Hash Code

比较Client Hash Code 和 CA Hash Code 是否一致

![image-20210624164315042](..\..\references-figures\image-20210624164315042.png)



**TLS 第三次握手**

客户端验证完成服务器身份后。

1. 客户端会产生一个新的 **随机数pre-master**。
2. 使用 数字证书中的 服务器**RSA公钥 加密该 pre-master**，并且发送给 服务端。

到这里，双方交换了了3个随机数：**Client Random、Server Random、pre-master**。

**双方根据这三个随机数，生成 会话密钥 Master Secret**，它是对称密钥，用于通信过程中的信息加密。

3. **Change Cipher Spec**：**告知服务端开始使用 会话密钥** 进行加密通信。
4. **Encrypted Handshake Message**：**将之前发送的数据打包为摘要，再使用 会话密钥 加密，给服务端做个验证，验证加密通信是否可用 以及 握手过程中信息是否被篡改。**



**TLS 第四次握手**

同样，服务端 发送 Change Cipher Spec 和 Encrypted Handshake Message 消息。

通知客户端开始使用会话密钥加密通信，并且打包所有发送的数据做一个摘要，用于验证加密通信是否可用以及握手信息的安全性。

自此，TLS 握手过程完毕，后续使用HTTP协议进行通信，不过所有信息都使用 会话密钥 进行加密和解密。



****

##### RSA 密钥交换算法的缺陷

RSA 算法的主要缺陷在于：**RSA不是向前安全的，也就是说，客户端传递pre-master随机数是使用 RSA公钥加密的，服务端则使用RSA私钥进行解密得到随机数，如果 RSA私钥泄漏，那么产生的 会话密钥就会被破解，过去被第三方截获的所有 TLS 通信密文都会被破解。**

为了解决这个问题，出现了 DH 密钥协商算法。

###### DH 密钥交换算法

简单来说，服务端和客户端双方都会各自生成随机私钥，并且根据DH算法计算出公钥，然后TLS握手时双方交换各自的公钥，这样 双方都持有 自己的私钥 和 对方的公钥，然后各自根据公私钥计算出 一个随机数，双方的该随机数是相同的。然后就可以使用该随机数作为后续对称加密时使用的密钥。

**DH密钥交换过程中，即使第三方获取了 TLS 握手阶段传递的公钥，在不知道私钥的情况下，无法计算出会话密钥。**

并且，**关键是 每一次对称加密密钥 都是 实时生成的，实现前向保密。**

