#### 2.1 HTTP 常见面试题

1. HTTP 基本概念
2. Get和Post
3. HTTP特性
4. HTTPS和HTTP
5. HTTP1.1/HTTP2/HTTP3的演变

![image-20210620185501963](..\..\references-figures\image-20210620185501963.png)

##### 1. HTTP基本概念

- HTTP是什么？

HTTP叫做超文本传输协议(HyperText Transfer Protocol)，是一个应用层协议，用于用于控制双方或者多方计算机之间交流通信的规范、以及相关的各种控制和错误处理方式。

**[协议]**：所谓协议，就是一种约定和规范，在计算机世界中，就是规定了计算机之间通信的规范，以及相关的各种控制和错误处理方式。

**[传输]**：所谓传输，就是将一些东西，从A运送到B，就是将一些数据二进制流从一台计算机，传到另一台计算机。不要小看这两个字，**这说明了HTTP协议是一个双向协议，双方都需要遵守HTTP进行数据传输。**比如浏览器和服务器之间规定用HTTP协议通信，浏览器将请求数据发送给服务器，服务器返回一些数据给浏览器，然后浏览器渲染显示数据。

**[超文本]**：所谓超文本，就是"超级文本"，就是可以包含文本、图片、视频的混和，而且有超链接。

HTML就是最常见的超文本标记语言，本身只是纯文字文件，但内部使用了很多标签来定义图片、视频等的连接，然后经过浏览器的渲染，显示出来的就是一个有文字、有画面的网页。

也就是说：**HTTP是在网络两点之间传输文字、图片、视频等超文本数据的约定和规范。**



##### 2. HTTP常见状态码

- ###### **五大类HTTP状态码**

![image-20210620191550620](..\..\references-figures\image-20210620191550620.png)

**1XX**:提示信息，是协议处理中的一种**中间状态**，还需要后续的操作。

**2XX**:成功，服务器**成功处理了客户端请求**。

[200 OK]：一切正常，如果是非HEAD请求，服务器**返回的响应头都会有 body 数据**。

[204 No Content]：正常，但是**响应头没有 body 数据**。

[206 Partial Content]：正常，应用于HTTP**分块下载或者断点续传，表示响应返回的body数据不是全部，只是其中一部分**。

**3XX**：表示**客户端请求的资源发生了变动**，需要客户端用新的URL重新发送请求获取资源，也就是**重定向**。

[301 Moved Permanently]：表示**永久重定向**，说明请求资源已经不存在，需要改用新的URL访问。

[302 Found]：表示**临时重定向**，请求资源还在，但暂时需要使用另一个URL来访问。

**301和302都会在响应头里使用 Location，指明后续跳转的URL，浏览器会自动重定向新的URL**。

[304 Not Modified]：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，**也叫缓存重定向，用于缓存控制。**

**4XX**：表示 **客户端请求的报文有误，服务器无法处理 或者 服务器禁止了访问该资源。**

[400 Bad Request]：客户端请求的报文有错误，但只是一个笼统的错误。

[403 Forbidden]：表示服务器禁止访问资源，并不是客户端请求出错。

[404 Not Found]：表示请求的资源在服务器上不存在或者没有找到，所以无法提供给客户端。

**5XX**：表示 **客户端请求报文正确，但是服务器处理时内部出现错误，属于服务器端的错误码。**

[500 Internal Server Error]：和400类型一样，是个笼统的错误码。

[501 Not Implemented]：表示客户端请求的功能还不支持，类似"敬请期待"。

[502 Bad Gateway]：表示服务器作为网关或者代理时返回的错误码，表示服务器自身正常，访问后端服务器发生了错误。



##### **3. HTTP 常见字段**

- Host

客户端发送请求时，用来指定服务器的域名，有了host字段，就可以将请求发送到 同一台服务器上的不同网站。

- Content-Length 

服务器返回时，Content-Length字段表明本次回应的数据长度。

- Connection

Connection 字段最常用于客户端要求服务器使用TCP持久连接，以便其它请求复用。

- Content-Type

Content-Type字段用于服务器回应时，告诉客户端，本次数据是什么格式。客户端请求时Accept:\*/*表示所有格式都能接收，服务器回应时 Content-Type: text/html; charset=utf-8，表示发送的是网页，并且编码为utf-8。

- Content-Encoding

Content-Encoding说明数据的压缩方式，表示服务器返回的数据使用了什么压缩格式。

Content-Encoding: gzip，表示服务器返回的数据采用了 gzip 方式压缩，告诉客户端可以使用这种方式解压。

客户端请求时，Accept-Encoding 字段说明自己接受哪些压缩方式。



##### 4. Get 和 Post

- Get 和 Post 的区别？

Get**方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。**

而Post则是向 URI 指定的资源提交数据，数据就放在报文的body中。

- Get 和 Post 都是安全和幂等的吗？

Get方法是安全且幂等的，因为它是只读操作，不论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。

Post方法因为是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，不是幂等的。



##### 5. Http特性

- **Http1.1的优点有哪些，怎么体现的？**

Http最突出的优点就是：**简单、灵活、易于拓展、应用广泛和跨平台。**

1. 简单：HTTP基本的报文格式就是 header+body，头部信息也是 key-value 简单文本的形式，易于理解。

2. 灵活易拓展：HTTP协议中的各种请求方法、URI\URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和拓展。

    同时 HTTP 由于是 应用层协议，下层可以随意变化。**HTTPS 也就是在 HTTP 和 TCP 之间增加了 SSL\TLS 安全传输层，甚至 HTTP3 把 TCP层 换成了基于 UDP 的 QUIC。**

3. 应用广泛和跨平台：HTTP到处都是，同时天生具有跨平台的优越性。



- **那HTTP的缺点呢？**

HTTP协议里有优缺点一体的 **双刃剑**，就是 **无状态、明文传输**，同时还有一个大缺点 **不安全**。

1. **无状态双刃剑**：

好处：服务器不会去记忆HTTP的状态，所以不需要额外资源来记录状态信息，能减轻服务端压力，把更多的CPU和内存用来提供对外服务。

坏处：既然服务器没有记忆能力，在它完成有关联性的操作时就会非常麻烦。

​	比如：登录->添加购物车->下单->结算->支付，这一系列操作都需要知道用户的身份，但是服务器不知道这些请求是关联的，是同一个用户的请求，所以每次都需要问一遍身份信息。

**对于无状态问题，解决方案有很多种，比较简单的就是 使用Cookie。**

Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。也就是 **客户端第一次请求的时候，服务器产生Cookie 并记录客户端和对应的Cookie，在响应报文中添加Cookie，客户端收到Cookie后保存在本地，第二次请求时带上这个Cookie，服务器就知道该请求的身份信息，可以实现免登录功能，解决HTTP的无状态问题。**

2. **明文传输**：数据裸奔，很不安全。

3. **不安全：**

    - 通信使用明文不加密，内容可能被窃听。
    - 不验证通信方的信息，有可能遭遇伪装，比如访问假的淘宝。
    - 无法证明报文的完整性，所以有可能报文已经被篡改，比如网页上植入垃圾广告。

    HTTPS解决HTTP的不安全问题，也就是加 HTTP 和 TCP 之间加入了 SSL\TLS 层，使得安全上达到了极致。



- **HTTP1.1的性能怎么样？**

HTTP协议基于 **TCP/IP**，并且使用 **请求-应答** 的通信模式，所以性能的关键就在这两点。

1. 长连接

早期的HTTP1.0性能上有很大的问题，每次一个请求，都会新建一个TCP连接进行三次握手，而且是串行请求，每次都要做一次TCP连接的建立和断开，添加了通信开销。

为了解决TCP频繁建立和断开连接的问题，HTTP1.1 使用了 **长连接，也叫持久连接，减少了TCP连接的重复建立和断开产生的大量开销，减轻了服务器的资源消耗和负载。**

长连接时，只要任意一端没有提出断开连接，则保持TCP连接状态。

2. 管道网络传输

由于 HTTP1.1使用长连接的方式，所以 pipeline式的传输是可能的，也就是 在同一个TCP连接中，客户端可以发起多个请求，不需要等待前面的请求返回，就可以发送后续的请求，可以减少整体的响应时间。

但是，服务器还是按照顺序处理请求，先回应A请求，完成后再回应B请求，如果前面的回应很慢，则会阻塞后面的请求，这叫做 **队头阻塞。**

3. 队头阻塞

由于队头阻塞，加剧HTTP协议的性能问题，如果前面的客户端请求迟迟没有回应，则会阻塞后面所有的请求，会导致客户端一直请求不到数据。

总之，HTTP1.1的性能一般般，所以才会有后面 HTTP2, HTTP3 的优化。



##### 6. HTTP 和 HTTPS

- **HTTP 和 HTTPS 有哪些区别？**

1. HTTP信息明文传输，存在安全问题，而HTTPS则解决HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL安全协议，使报文能加密传输。
2. HTTP连接建立相对简单，TCP三次握手后就可以开始HTTP的报文传输，但HTTPS在TCP三次握手后，还需要SSL的握手过程，才能进行加密报文传输。
3. HTTP端口是80，HTTPS端口号是443
4. HTTPS协议需要向 CA(证书权威机构) 申请数字证书，来保证服务器的身份是可信的。



- **HTTPS 解决了HTTP的哪些问题？**

1. 窃听风险，通信链路上可以获取通信内容。
2. 篡改风险，可以中间人修改通信内容。
3. 冒充风险，可能访问到冒充假的网站。

HTTPS 通过在 HTTP 和 TCP 之间加入了 SSL\TLS 协议，解决了上面的问题。

1. 信息加密，防止通信信息被截获。
2. 校验机制，防止通信内容被篡改。
3. 身份证书，防止冒充。



- **HTTPS 是怎么实现上面的功能的？换句话说，是如何解决上面的问题的？**

1. **混合加密实现信息的机密性，解决被窃听的风险。**
2. **摘要算法实现信息的完整性，它能为数据生成唯一的指纹，用于验证数据完整性，解决被篡改的问题。**
3. **将服务器公钥放入到数字证书中，解决被冒充的风险。**

**1 混和加密**

HTTPS采用的是 对称加密 和 非对称加密 结合的 混和加密 方式。

- 在通信建立前使用 **非对称加密的方式交换 会话密钥，后续就不再使用非对称加密。**
- 在通信过程中全部使用 **对称加密的会话密钥 的方式加密明文数据。**
- 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- 非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但是速度慢。

**2 摘要算法**

摘要算法用来验证数据的完整性，能为数据生成唯一的"指纹"，用于验证数据完整性，解决了篡改的风险。

- 客户端发送数据明文时会使用摘要算法计算出指纹，将 明文+指纹 一起加密后，发送到服务器，服务器解密后，在按照相同的摘要算法 计算 明文的指纹，对比计算出来的指纹和客户端发送的指纹是否一致，如果一致则说明 数据是完整的，没有被篡改过。

**3 数字证书**

通过数字证书的方式保证服务器公钥的身份安全，解决冒充的风险。

1. 服务器将自己的公钥注册到CA
2. CA使用CA私钥将服务器的公钥进行数字签名，并颁发数字证书
3. 客户端拿到了服务器的数字证书后，使用CA公钥进行确认，验证服务器证书的真实性
4. 然后使用服务器公钥进行加密传输，服务器使用私钥进行解密



- HTTPS 是如何建立连接的？其间交互了什么？

1. **ClientHello**

首先，由客户端向服务器发起加密通信请求，也就是ClientHello请求。

客户端向服务器发送：

1）客户端支持的SSL协议版本。

2）客户端生成的随机数(Client Random)，用于后面的会话密钥生成。

3）客户端支持的密码套件列表，如RSA加密算法。

2. **ServerHello**

1）确定SSL协议版本，如果浏览器不支持，则关闭加密通信。

2）服务器产生的随机数(Server Random)，用于后面的会话密钥生成。

3）确定密码套件列表，如果RSA加密算法。

4）**发送服务器的数字证书**。

3. **ClientResponse**

客户端收到服务器的数字证书后，使用浏览器或者OS中的CA公钥，确定数字证书的真实性。

如果证书没有问题，客户端使用数字证书中的私钥进行加密报文。

1）发送一个随机数(pre-master key)，该随机数会被服务器公钥加密。

2）加密通信算法改变通知，表示随后的信息都将会使用 会话密钥 加密通信。

3）客户端握手结束通知，表示客户端的握手阶段已经结束，同时将之前的所有内容数据做个摘要，用来供服务器校验。

4. **ServerResponse**

服务器收到客户端的第三个随机数后，使用协商的加密算法，计算出本次通信的会话密钥。

1）发送加密算法改变通知。

2）服务器握手阶段结束通知，同时打包摘要，用于客户端校验。

整个SSL握手过程结束，进入客户端和服务器加密通信，使用普通的HTTP协议进行，其中使用 会话密钥 加密内容。



##### 7. HTTP1.1 HTTP2 和 HTTP3

- HTTP1.1 相比 HTTP1.0 性能上有什么改进？

1. 使用长连接代替短连接，降低了1.0中频繁创建销毁连接资源的消耗。
2. 支持管道操作，也就是 可以在同一个TCP连接中发送多次请求，而不需要等待第一个请求的响应返回，减少整体的响应时间。

- HTTP 1.1 的性能瓶颈？有什么不足？

1. 头部数据Header没有经过压缩就发送，只能压缩Body部分，每次互相发送相同的头部造成的浪费较多。
2. 服务器是按照请求的顺序响应的，如果一个请求时服务器响应较慢，就会造成后面的请求阻塞，也就是 **队头阻塞。**
3. 没有请求优先级控制。
4. 请求只能从客户端开始，服务端只能被动响应。



- HTTP 2 是怎么优化的？是怎么改进1.1的问题的？

HTTP 2 是基于 HTTPS 的，所以HTTP2也是加密传输，有安全保证的。

1. **头部压缩**

HTTP2会进行头部压缩，如果同时发送多个请求，请求头是一样的，或者相似的，那么协议会进行 **消除重复的部分。**

所谓的 **HPACK算法：在客户端和服务器同时维护一张head信息表，所有字段都会存入这个表，生成索引号，以后就发送索引号，而不是相同的字段了。**

2. **二进制格式**

HTTP2 不再是使用1.1中的 纯文本形式的报文，而是全面使用了 **二进制格式，头信息和数据体都是二进制，**并且统称为帧：头信息帧和数据帧。减少了 文本和二进制的转化过程，提高效率。

3. **数据流**

**HTTP2的响应数据包不是按照顺序发送的，同一个连接中连续的数据包，可能是不同的响应，所以，必须要对数据包标记，指出它是属于哪一个回应。**

**每个请求或者响应的所有数据包，称为一个 数据流Stream，每个数据流都标记 一个唯一的编号，其中规定 客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。**

**客户端还可以指定数据流的优先级，优先级高的请求，服务器优先响应。**

4. **多路复用**

HTTP2 可以 **在一个连接中调整多个请求和响应的顺序，而不需要按照顺序一一对应。**

也就是移除了 1.1 中的串行请求，不需要排队等待，也就不会出现 队头阻塞问题。

比如：一个TCP连接中，服务器收到了客户端A和B两个请求，如果发现 A 处理过程很耗时，可以就回应A请求已经处理好的部分，先进行回应B请求，完成后再响应A请求的剩下部分。

5. **服务器推送**

HTTP2 在一定程度上改善了 传统的 请求-响应 模式，服务端不再是被动的响应，也可以主动的向 客户端发送消息。

比如：在浏览器刚刚请求HTML的时候，服务器就可以提前把可能会用到的JS, CSS等静态文件主动发送给客户端，提高响应速度，也就是 服务器推送。



- HTTP2 有什么缺陷？HTTP3 做了哪些优化？

HTTP2的主要问题在于：多个HTTP请求复用一个TCP连接，当出现了丢包后，就会触发TCP的重传机制，这样在一个TCP连接中 **所有的HTTP请求都需要等待这个 丢包重传。**

**HTTP3 将 HTTP 下层的 TCP 协议 换成了 UDP**！并且使用 升级了的 SSL1.3

UDP 是不管顺序，也不管丢包的，所以不会出现 HTTP1.1中的队头阻塞，和HTTP2中的丢包重传导致请求阻塞的问题的。

但是 UDP 是不可靠传输，所以，这里使用 **基于UDP的 QUIC 协议 来实现类似 TCP 的可靠性传输。**

1. **QUIC** 实现了一套机制来保证传输可靠，当某个流发生丢包时，只会阻塞这个流，其它流不会收到影响。
2. TLS3(SSL3),头部压缩算法也升级成立 **QPack**。
3. HTTPS 要建立一个连接，需要TCP 3 次握手，然后是 TLS1.3版本中的 3次握手。**QUIC 直接把以往的TCP和SSL1.3中的6次交互 合并成了 3次。**

