### HTTPS 中的 DH DHE ECDHE 密钥协商算法

##### 前言

我们前面说到了，为了保证信息传输时的性能，在通信过程中使用的是 非对称加密算法，但是非对称加密算法的密钥必须是保密的，**为了保证 密钥协商产生过程的安全，在 TLS 握手过程中使用 对称加密算法 来进行 会话密钥的产生，而常用的该算法，是 RSA 算法**。

前面又说到了 **RSA 算法的缺陷，由于 该算法 基于握手过程中的3个随机数产生，而第三个随机数 pre-master 是使用 服务端私钥得到，客户端使用公钥解密。如果该服务端私钥暴露，那么之前所有的 TLS 握手过程的信息全部都泄漏**。

因此，我们说 RSA 是 **前向不安全**的。

而为了解决这个问题，产生了 DH 以及 DH 基础上改进的 DHE 和 ECDHE 算法。常用的是 DHE 和 ECDHE。



##### DH

前面也提到了，**DH 算法中，客户端和服务端双方都会生成 各自的 公钥和私钥，并且将公钥交给对方。然后使用DH中的算法可以利用 双端各自持有的 私钥和公钥 计算出一个 相同的 对称加密密钥，作为 会话密钥使用**。

实现细节在于：DH算法是使用 **离散对数的性质来产生会话密钥的。**

离散对数：

![image-20210624201233155](..\..\references-figures\image-20210624201233155.png)

其中，a, p 为可见参数，即对外公开。而 i 作为 私钥 来生成公钥 b。

于是，小红和小明双方都首先生成各自的私钥 a 和 b，并且根据离散对数生成公钥 A 和 B。其中G和p为公开参数。

A = G ^ a (mod p)

B = G ^ b (mod p)

将公钥发送给对方后，根据离散对数幂运算的交换率，就可以计算出 一个相同的 会话密钥。

B ^ a (mod p) = A ^ b (mod p) = K，使用K作为会话中使用的对称加密密钥。

另外，该算法还依赖于 **离散对数的"运算单向性"**，即 可容易地根据 私钥 i 的值 计算出 公钥 b，而非常困难地从 公钥b 反推出 私钥 i 的值。因此保证了 私钥的安全。



##### **DHE**

DHE 算法指的是，**双方每次进行密钥协商时，产生的私钥都是随机产生的，临时的，改变的**。该E指的是 ephemeral(临时性的)。带来的是 **前向安全性**。

因为，如果每次不是重新随机产生各自的私钥，那么就不具备有前向安全的性质，即只要破解了当前的私钥，那么前面的所有SSL握手过程的信息全部被破解。



##### **ECDHE**

ECDHE 是减少了 DHE 中的运算量，因为 DHE 中基于离散对数会使用大量的乘积运算。

而 ECDHE 则使用 **椭圆曲线 使用更少的计算量得到公钥，来生成 会话密钥。**

会话密钥产生过程：

1. 双方确定使用的椭圆曲线，和曲线上的基点G
2. 双方产生随机数作为私钥d，并与基点G相乘得到公钥Q(Q=dG)
3. 交换各自的公钥，各自持有自己的私钥d和对方的公钥Q，在圆锥曲线上找到一点 (x, y)=dQ，由于曲线的对称性质，双方找到的点的x坐标相同，所以将其作为会话密钥

与 RSA 过程的区别上：

在第二次握手，Server确定了TSL版本、套件列表、以及发送服务端数字证书给客户端 之外，还需要发送 曲线的信息 以及 根据曲线计算出的 公钥。

后续，使用 Client Random，Server Random，以及ECDHE算法计算的 共享密钥 3个材料计算出 最终的会话密钥。

这是因为，TSL不信任服务端或者客户端产生的伪随机数的可靠性。

再后续，同样，双方再历过两次握手，告知对方开始进行加密通信，并且将已经发出的数据打包生成摘要，用于验证会话密钥的可用性，以及协商过程中是否存在篡改。