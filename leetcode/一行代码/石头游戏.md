### 石头游戏

#### 游戏规则：你和你的朋友⾯前有⼀排⽯头堆，⽤⼀个数组 piles 表⽰，piles[i] 表⽰第 i 堆⽯⼦有多少个。你们轮流拿⽯头，⼀次拿⼀堆，但是只能拿⾛最左边或者最右边的⽯头堆。所有⽯头被拿完后，谁拥有的⽯头多，谁获胜。

##### 假设你们都很聪明，由你第⼀个开始拿，请你写⼀个算法，输⼊⼀个数组piles，返回你是否能赢（true 或 false）。

##### 注意，⽯头的堆的数量为偶数，所以你们两⼈拿⾛的堆数⼀定是相同的。⽯头的总数为奇数，也就是你们最后不可能拥有相同多的⽯头，⼀定有胜负之分。


比如，

piles = [2, 1, 9, 5]，你先拿，可以选择 2 或者 5，你选择2。

piles = [1, 9, 5]，对手可以拿 1 或 5，他选择5。

piles = [1, 9]，轮到你，你拿 9 。

piles = [1]，对手拿 1。

这样，你总共拥有 2 + 9 = 11 颗石头，对手有 5 + 1 = 6 颗石头，你赢了，算法应该返回 true。

可以看到，并不是每次选最大的，第一次选 2 而不是 5，如果选 5，那么后面的 9 就暴露给对手了，就要输了。



这也是强调双方都很聪明的原因，算法求解的是最优决策下你能否赢。

这题又涉及到两人的博弈，也可以使用动态规划算法暴力试，比较麻烦。

**但我们只要对规则深入思考，你就会发现，只要你足够聪明，你就是必胜，因为你是先手。**

为什么呢？

**因为规则规定了，石头堆的数量必须是偶数，而石头的总数必须是奇数，这两个规则看视增加游戏公平性，实际上让这个游戏失去平衡性。**

因为 **你总是可以拿到 全部的 偶数堆 或者 奇数堆 的石头，然而 由于石头总数是奇数，所以 偶数堆石头数一定不等于奇数堆，**所以，你只要先发现 偶数堆 或者 奇数堆 石头总数最多的 是 偶数还是奇数，你就能赢。

```java
public boolean stoneGame(int[] piles) {
    return true;
}
```

