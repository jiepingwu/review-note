### ⼀、Nim 游戏

#### 游戏规则是这样的：你和你的朋友⾯前有⼀堆⽯⼦，你们轮流拿，⼀次⾄少拿⼀颗，最多拿三颗，谁拿⾛最后⼀颗⽯⼦谁获胜。

##### 假设你们都很聪明，由你第⼀个开始拿，请你写⼀个算法，输⼊⼀个正整数n，返回你是否能赢（true 或 false）。

##### ⽐如现在有 4 颗⽯⼦，算法应该返回 false。因为⽆论你拿 1 颗 2 颗还是 3颗，对⽅都能⼀次性拿完，拿⾛最后⼀颗⽯⼦，所以你⼀定会输。

⾸先，这道题肯定可以使⽤动态规划，因为显然原问题存在⼦问题，且⼦问题存在重复。但是因为你们都很聪明，涉及到你和对⼿的博弈，动态规划会⽐较复杂。



21点问题。

**我们遇到这种问题一般都是反向思考：**

1. 如果我能赢，那么最后我取石头的时候就必须要剩下 1~3 颗石子，这样我才能一次拿完。
2. 如果我取石头的时候要1~3颗石子，那么对手拿的时候就必须只剩下4颗石子，这样无论他怎么拿，都总会剩下1~3颗石子，我就能赢。
3. 怎么保证对方拿的时候只剩下4颗石子呢，那么需要我拿的时候剩下 4+1 ~ 4+3 也就是 5~7颗石子，这样就能保证他拿的时候剩下 4 颗。
4. 那么怎么我拿的时候还剩下 5 ~ 7 颗呢，需要对方拿了还剩下 8 颗。

于是，我们发现，只要 n 为 4 的倍数，就陷入了陷阱中，怎么样我们都会赢。所以code就只有一行。

只要上面我面对的不是 4 的倍数，我就能让对方面对 4 的倍数颗石子，必胜。

##### code

```java
public boolean canWinNim(int n) {
    return n % 4 != 0;
}
```

