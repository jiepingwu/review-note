##### leetcode  10 正则表达式匹配

一道DP

```shell
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

示例 1：
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```



```shell
状态：f[i][j] 表示 s的前i个字符 与 p的前j个字符 是否可以匹配
转移：
	1. p[j]为正常字符，那么f[i][j] = f[i-1][j-1] && p[j] == s[i]
	2. p[j]为 '.'，那么f[i][j] = f[i-1][j-1]
	3. p[j]为 '*'，那么需要讨论 '*'实际匹配了s中的几个字符，比如'a*'。
		如果匹配0个a，f[i][j] = f[i][j-2]
		如果匹配1个a，f[i][j] = f[i-1][j-2] && (s[i] == p[j-1] || p[j-1] == '.')
		如果匹配2个a，f[i][j] = f[i-2][j-2] && ((s[i] == p[j-1] && s[i-1] == p[j-1]) || (p[j-1] == '.'))
		...
	其中，第3种情况中:
		f[i][j] = f[i][j-2] || f[i-1][j-2] && s[i]匹配p[j-1] || f[i-2][j-2] && s[i-1:i]匹配p[j-1] ...
	带入 i = i - 1
	那么 f[i-1][j] = f[i-1][j-2] || f[i-2][j-2] && s[i-1]匹配p[j-1] || ...
	可以发现，f[i][j]的第二项 和 f[i-1][j]的第一项 相比，相差 s[i]匹配p[j-1] (类似错位相减)
	=> f[i][j] = f[i][j-2] || ( f[i-1][j] && s[i]匹配p[j-1] )
	得到p[j]为'*'的转移方程： 
	   f[i][j] = f[i][j-2] ||( f[i-1][j] && (s[i] == p[j-1] || p[j-1] == '.') )
```



dp编码上的技巧，一般可以将dp数组容量+1，即 m, n的dp空间，dp[]数组 为 dp\[m+1][n+1]

对于这里的字符串 s 和 p，可以 s = " " + s; p = " " + p	以init动规数组。

```java
class Solution {
    public boolean isMatch(String s_, String p_) {
        int m = s_.length();
        int n = p_.length();

        char[] s = (" " + s_).toCharArray();    // " aa"
        char[] p = (" " + p_).toCharArray();    // " a*"

        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;
		
        // 注意这里的循环, i >= 0 而 j >= 1
        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // p[j] 为 正常字符
                if (p[j] != '.' && p[j] != '*') {
                    f[i][j] = i > 0 && f[i - 1][j - 1] && s[i] == p[j];
                }
                // p[j] == '.'
                else if (p[j] == '.') {
                    f[i][j] = i > 0 && f[i - 1][j - 1];
                }
                // p[j] == '*'
                else if (p[j] == '*') {
                    f[i][j] = (j > 1 && f[i][j - 2]) ||	// 注意边界
                            (i > 0 && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.'));
                }
            }
        }

        return f[m][n];
    }
}
```

