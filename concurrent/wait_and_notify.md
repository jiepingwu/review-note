### wait and notify

#### 为什么会有等待通知机制？

​	如果没有等待通知机制，当线程并发访问共享资源的时候，就需要通过轮询来实现，这样会消耗CPU资源。加入等待通知机制后就可以将请求资源失败的线程加入waitSet等待队列，然后由其它访问共享资源结束的线程通过notify唤醒等待队列中的线程。



#### 等待通知机制

- 一个锁对应一个入口等待队列，不同锁的入口没有任何关系。
- wait(), notify(), notifyAll() 要在synchronized内部使用，而且，如果锁的对象是this，需要使用 this.wait(), this.notify(), this.notifyAll()。

![等待队列图](https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-img20200312141043.png)

- 问题1 **虚假唤醒**

    在上面的wait中，使用了if 条件判断。当notity唤醒的那一刻，线程 **曾经** 要求的条件得到了满足，从这一刻开始，到去条件队列中唤醒线程，到再次尝试获取锁的过程是有 **时间差**的，可能当再次获取到锁的时候，线程曾经的条件可能不满足了。

    所以，在 **竞争条件的判断时，应该使用 while循环判断，而不是 if。**

    *为什么while就可以？*

    ​	因为被唤醒的线程再次获取到锁之后，**是从wait()之后开始执行的，**所以会再次判断条件。

- 问题2 **notify和notifyAll的区别**

    - notify：**随机唤醒一个**，一个线程调用锁对象的notify()方法，会唤醒一个在该对象锁上调用wait()方法后被挂起的线程，也就是唤醒等待队列中的一个线程，而唤醒哪个，是随机的。
    - notifyAll：**全部唤醒，** 唤醒等待队列中的所有线程，去请求锁。

- 问题3 **什么时候使用 notify()**

    - 所有等待线程拥有相同的等待条件
    - 所有线程被唤醒后，执行相同的操作
    - 只需要唤醒一个线程

    **notify()的典型应用场景是 线程池。**



#### MESA模型

MESA模型中 **每个条件变量都对应一个条件等待队列。**

![img](https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-img20200315110223.png)

而 Java内置监视器模型就只会有一个 **[隐形的]** 条件变量。

- 如果synchronized修饰的是普通方法，条件变量就是this
- 如果synchronized修饰的是静态方法，条件变量就是class类型实例
- 如果synchronized块，条件变量就是对应的锁对象