### 锁的升级过程

#### 为什么要有锁升级？

​	synchronized内置锁，最开始的时候是没有锁升级的优化的，都是直接使用的 **操作系统提供的重量级锁**，而向操作系统申请锁资源是比较消耗资源的，其中存在内核态和用户态的切换，以及创建监视器锁对象。

​	所以，JVM为了优化加锁操作，实现了锁升级机制，也就是说，并不是所有的锁都直接使用 操作系统的重量级锁，不是所有申请锁都需要 操作系统的调度。从而避免了大量资源消耗。



#### 锁升级过程

1. 新生态(New)：对象刚刚创建出来，就是新生状态，可以设置默认开启偏向锁(对象创建后直接是偏向锁状态，这时候是偏向一个哑对象)。
2. 偏向锁：第一次发生锁请求，锁对象将对象头中的偏向锁线程ID以CAS的方式改为 申请锁的线程ID，成功表示获取锁成功。
 - 偏向锁的撤销：偏向锁不会主动撤销，只有遇到其它线程竞争时才会执行撤销，**由于偏向锁撤销需要直到偏向线程的状态，所以需要等到safe-point时进行。**
 - 而偏向锁撤销有两种情况：
     - 撤销：当前偏向线程已经执行完，或者已经不存在，则直接撤销偏向锁，变为新生状态。
     - 升级：当前偏向线程还持有偏向锁，还没有执行完，则将偏向锁升级为CAS锁。
3. CAS锁(无锁，轻量级锁)：偏向锁申请失败，也就是说，当存在并发请求偏向锁时，CAS失败，当达到safe-point时，将偏向线程挂起，将偏向锁升级为CAS锁。
 - **轻量级锁的获取过程：**
 - 获取锁时，JVM判断是否已经是重量级锁，如果不是，**在当前线程栈栈帧中申请一块空间 用于记录 该锁的锁记录 Lock Record，用于保存对象头的Mark Word。**
 - **JVM使用CAS将对象头中Mark Word 更新为指向该 Lock Record的指针，并将锁记录里的 Owner指针指向对象头的Mark Word。**
 - 如果CAS成功，则当前线程为持有该对象锁。如果失败，检查对象Mark Word是否指向当前Lock Record(是否锁重入)，如果不是锁重入，则表示CAS获取锁失败，进行自旋，默认当自旋次数达到10次，升级为重量级锁。
 - **轻量级锁的释放过程：**
 - **释放锁时，通过CAS将线程栈中的Lock Record中保存的 Displaced Mark Word 替换回当前对象头的Mark Word。**
 - 替换成功表示释放成功，释放失败，说明已经膨胀为重量级锁，则在执行完同步代码块释放锁的同时唤醒被挂起的线程。
4. 重量级锁
- 重量级锁加锁过程：分配一个ObjectMonitor对象，把Mark Word锁标志置为10，然后Mark Word存储指向 ObjectMonitro对象的指针。
- ObjectMonitor对象，维护两个队列和一个指针。所有请求锁的线程都被包装为 ObjectWaiter对象。
- 请求锁时，ObjectWaiter对象先进入 队列1，请求锁成功的进入 _Owner区域，调用wait后进入WaitSet。