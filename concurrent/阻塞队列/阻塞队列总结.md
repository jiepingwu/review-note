### Blocking Queue æ€»ç»“

##### å¹¶å‘é˜Ÿåˆ—

Java å¹¶å‘é˜Ÿåˆ—æŒ‰å®ç°æ–¹å¼è¿›è¡Œåˆ’åˆ†å¯ä»¥åˆ†ä¸º2ç§ï¼š

1. é˜»å¡é˜Ÿåˆ—
2. éé˜»å¡é˜Ÿåˆ—

![img](https://rgyb.sunluomeng.top/20200822140429.png)

###### ä¸ºä»€ä¹ˆå­˜åœ¨è¿™ä¹ˆå¤šç§é˜Ÿåˆ—ï¼Ÿ

é”æœ‰åº”å¯¹ä¸åŒæƒ…å½¢çš„é”ï¼Œé˜Ÿåˆ—è‡ªç„¶ä¹Ÿæœ‰åº”å¯¹å„ç§æƒ…å½¢çš„é˜Ÿåˆ—ã€‚

![img](https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-img20200816221812.png)

ä½ ä¼šå‘ç°ï¼Œblocking queue ç›¸æ¯”äº non-blocking queue è€Œè¨€ï¼Œå¤šäº† take() é˜»å¡çš„ç§»é™¤ and put() é˜»å¡çš„æ’å…¥ã€‚

**blocking queue and non-blocking queue å¸¸ç”¨æ–¹æ³•æ¯”è¾ƒ**

![img](https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-img20200817202028.png)

---

##### å¹¶å‘é˜Ÿåˆ—æ€»ç»“

![img](https://rgyb.sunluomeng.top/6af89bc8gw1f8q2grytifg204g02s746.gif)

###### ArrayBlockingQueue

â€‹	ArrayBlockingQueue å†…éƒ¨ä½¿ç”¨ **æ•°ç»„** å®ç°ï¼Œæ˜¯ä¸€ä¸ª **æœ‰ç•Œé˜Ÿåˆ—**ï¼Œå¹¶ä¸”å¯ä»¥æŒ‡å®š capacityã€‚

**æ„é€ å™¨**

```java
public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity <= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull =  lock.newCondition();
}
```

â€‹	é»˜è®¤æƒ…å†µä¸‹ï¼Œä¾æ—§æ˜¯ **éå…¬å¹³é”** å®ç°ï¼Œä¸ä¿è¯çº¿ç¨‹æŒ‰é˜»å¡çš„é¡ºåºè®¿é—®é˜Ÿåˆ—ã€‚

**å¦å¤–ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼š**

- ArrayBlockingQueue ä¸­åªä½¿ç”¨äº†ä¸€ä¸ª ReentrantLockï¼Œå¹¶ä¸”ä¸¤ä¸ªæ¡ä»¶é˜Ÿåˆ— notEmpty and notFull éƒ½åœ¨è¯¥AQSä¸­ã€‚ä¹Ÿå°±æ˜¯è¯´ **ArrayBlockingQueueä¸­çš„ ç”Ÿäº§è€… å’Œ æ¶ˆè´¹è€… åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ª(ç”Ÿäº§è€…æˆ–è€…æ¶ˆè´¹è€…)å¯ä»¥è®¿é—®é˜Ÿåˆ—ã€‚** å¹¶å‘åº¦è¾ƒä½ã€‚

**æºç ä¸­éœ€è¦æ³¨æ„çš„ç‚¹ï¼š**

- **put and take æ–¹æ³•**

    - ```java
            public void put(E e) throws InterruptedException {
                Objects.requireNonNull(e);
                final ReentrantLock lock = this.lock;
                lock.lockInterruptibly();
                try {
                    while (count == items.length)
                        notFull.await();
                    enqueue(e);
                } finally {
                    lock.unlock();
                }
            }
        ```

    - ```java
            public E take() throws InterruptedException {
                final ReentrantLock lock = this.lock;
                lock.lockInterruptibly();
                try {
                    while (count == 0)
                        notEmpty.await();
                    return dequeue();
                } finally {
                    lock.unlock();
                }
            }
        ```

- **å†…éƒ¨ä½¿ç”¨å¾ªç¯æ•°ç»„ items[] (åŒæŒ‡é’ˆ, *takeIndex* and *putIndex*) å®ç°çš„ é˜Ÿåˆ—**

    - å¦å¤–ï¼Œä¸ºäº† å¾—åˆ°æ•°ç»„å…ƒç´ è®¡æ•°ï¼Œç»´æŠ¤ä¸€ä¸ª count å˜é‡ï¼Œå› ä¸ºåœ¨è·å–lockåcount++ï¼Œä¸éœ€è¦è€ƒè™‘å¹¶å‘ã€‚

    - ```java
            /**
             * Inserts element at current put position, advances, and signals.
             * Call only when holding lock.
             */
            private void enqueue(E e) {
                // assert lock.isHeldByCurrentThread();
                // assert lock.getHoldCount() == 1;
                // assert items[putIndex] == null;
                final Object[] items = this.items;
                items[putIndex] = e;
                if (++putIndex == items.length) putIndex = 0;		// ï¼ï¼šæ•°ç»„putå®Œ(åˆ°è¾¾å°¾éƒ¨å)æ›´æ–°ä¸ºindex 0
                count++;
                notEmpty.signal();
            }
        
            /**
             * Extracts element at current take position, advances, and signals.
             * Call only when holding lock.
             */
            private E dequeue() {
                // assert lock.isHeldByCurrentThread();
                // assert lock.getHoldCount() == 1;
                // assert items[takeIndex] != null;
                final Object[] items = this.items;
                @SuppressWarnings("unchecked")
                E e = (E) items[takeIndex];
                items[takeIndex] = null;
                if (++takeIndex == items.length) takeIndex = 0;		// ï¼ï¼šæ•°ç»„takeå®Œæˆåˆ°è¾¾å°¾éƒ¨åæ›´æ–°ä¸º index 0
                count--;
                if (itrs != null)
                    itrs.elementDequeued();
                notFull.signal();
                return e;
            }
        ```

- **ArrayBlockingQueue ä¸­å¸¦æœ‰ Collection å‚æ•°çš„æ„é€ æ–¹æ³• ä¸­åŠ äº†ğŸ”’**

    - ```java
            public ArrayBlockingQueue(int capacity, boolean fair,
                                      Collection<? extends E> c) {
                this(capacity, fair);
        
                final ReentrantLock lock = this.lock;
                lock.lock(); // Lock only for visibility, not mutual exclusion
                try {
                    final Object[] items = this.items;
                    int i = 0;
                    try {
                        for (E e : c)
                            items[i++] = Objects.requireNonNull(e);
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        throw new IllegalArgumentException();
                    }
                    count = i;
                    putIndex = (i == capacity) ? 0 : i;
                } finally {
                    lock.unlock();
                }
            }
        ```

    - ç±»ä¼¼åœ°ï¼ŒDCLå•ä¾‹ä¸­ä¸åŠ  volatile çš„å®ä¾‹ å¯èƒ½ä¼šåœ¨ åŠåˆå§‹åŒ–çŠ¶æ€ä¸‹ è®¿é—®å‘å¸ƒçš„å¼•ç”¨ï¼Œå¯¼è‡´å…¶å®ƒçº¿ç¨‹è®¿é—®åˆ° ä¸å®Œå…¨çš„å®ä¾‹ã€‚

    - è¿™é‡Œï¼Œä½¿ç”¨äº† Lock é”æ¥ä¿è¯ æ•´ä¸ªåˆå§‹åŒ–è¿‡ç¨‹çš„ happen-before åŸåˆ™ï¼Œå³ åˆå§‹åŒ–ç»“æœå¯¹åç»­å¼•ç”¨å‘å¸ƒ æ˜¯å¯è§çš„ã€‚

---

###### LinkedBlockingQueue

â€‹	æœ‰æ•°ç»„ï¼Œå°±æœ‰é“¾è¡¨ã€‚LinkedBlockingQueue ä¹Ÿç®—æ˜¯æœ‰ç•Œé˜Ÿåˆ—ï¼Œä¸è¿‡ å…¶é»˜è®¤å®¹é‡ä¸º Integer.MAX_VALUEï¼Œæ‰€ä»¥ JDK Docs ä¸­è¯´å…¶æ˜¯ optionally-boundedçš„ã€‚è€Œè¿™ä¹Ÿæ˜¯ Alibaba å¼€å‘æ‰‹å†Œ ä¸­ä¸å…è®¸ä½¿ç”¨Executorsåˆ›å»ºçº¿ç¨‹æ± çš„åŸå› ä¹‹ä¸€ã€‚

```java
public LinkedBlockingQueue() {
    this(Integer.MAX_VALUE);
}

public LinkedBlockingQueue(int capacity) {
  if (capacity <= 0) throw new IllegalArgumentException();
  this.capacity = capacity;
  last = head = new Node<E>(null);
}
```

**ç»†èŠ‚**

- LinkedBlockingQueue ä¸­ä½¿ç”¨ä¸¤ä¸ª Lock åˆ†åˆ«ç”¨äº ç”Ÿäº§ **putLock** å’Œ æ¶ˆè´¹ **takeLock**ï¼Œå¹¶ä¸” **putLock ä¸­çš„ Condition notFullï¼ŒtakeLock ä¸­çš„ Condition notEmptyã€‚**æ‰€ä»¥ï¼ŒLinkedBlockingQueueä¸­çš„puts å’Œ takes æ˜¯å¯ä»¥å®ç°å¹¶å‘çš„ã€‚

    - ```java
        
            /** Lock held by take, poll, etc */
            private final ReentrantLock takeLock = new ReentrantLock();
        
            /** Wait queue for waiting takes */
            private final Condition notEmpty = takeLock.newCondition();
        
            /** Lock held by put, offer, etc */
            private final ReentrantLock putLock = new ReentrantLock();
        
            /** Wait queue for waiting puts */
            private final Condition notFull = putLock.newCondition();
        ```

- **ç‰¹åˆ«æ³¨æ„**çš„æ˜¯ï¼ŒLinkedBlockingQueue ä½¿ç”¨äº† **"two lock queue algorithm"**ï¼Œé‡‡ç”¨äº† "**cascading notifiesï¼ˆçº§è”é€šçŸ¥ï¼‰**" æœºåˆ¶ï¼Œç”±putsç”Ÿäº§è€…è‡ªå·±é€šçŸ¥puts(ä¸€æ ·ï¼Œç”±æ¶ˆè´¹è€…è‡ªå·±é€šçŸ¥takes)ï¼Œè€Œåªåœ¨putsä»0åˆ°1æ—¶é€šçŸ¥ takes(sameï¼Œåªåœ¨takesä»full sizeåˆ°full size - 1æ—¶é€šçŸ¥puts)ã€‚

- ä¸Šè¿° **"cascading notifiesçº§è”é€šçŸ¥"çš„ç›®çš„åœ¨äºï¼š**ä¸ºäº†å°½å¯èƒ½å°‘çš„è·å–two lockï¼Œå°½å¯èƒ½å°‘åœ°å°è¯•è·å–é”ï¼Œå¢å¤§å¹¶å‘åº¦ã€‚

    - ä»¥ä¸Šå¯åœ¨ LinkedBlockingQueue JDK Docs ä¸­è§åˆ°è§£é‡Šã€‚

    - **ç»†èŠ‚1**ï¼šqueue count è®¡æ•°ä½¿ç”¨ AtomicInteger å˜é‡ï¼Œå› ä¸ºä½¿ç”¨äº† putLock and takeLock ä¸¤æŠŠé”ï¼Œå¯¼è‡´ puts and takes éƒ½ä¼šè®¿é—®countå˜é‡ã€‚

        - ```java
             /** Current number of elements */
                private final AtomicInteger count = new AtomicInteger();
            ```

    - **ç»†èŠ‚2ï¼š**æ— è®ºputsè¿˜æ˜¯takesï¼Œéƒ½ä¼šåœ¨æˆåŠŸåé€šçŸ¥è‡ªå·±æ¡ä»¶(notFull or notEmpty)çš„ç­‰å¾…é˜Ÿåˆ—ã€‚

    - **ç»†èŠ‚3ï¼š**å½“puts ä» 0 -> 1(æˆ–è€…takesä» full - full - 1)æ—¶ï¼Œæ‰ä¼šé€šçŸ¥ takes(æˆ–è€… puts)ï¼Œç›®çš„åœ¨äºå‡å°‘é”çš„è·å–ï¼Œè€Œå…¶é€šçŸ¥æœºåˆ¶(è”çº§é€šçŸ¥)ä¾èµ–äºä¸Šé¢çš„ç»†èŠ‚2ï¼Œ**ä¹Ÿå°±è¯´ï¼Œå¹¶ä¸åƒ ArrayBlockingQueue ä¸€æ ·ï¼Œæ¯æ¬¡puts(or takes)éƒ½ä¼šnotify takes(or puts)ã€‚(ArrayBlockingQueueè¿™æ ·åšæ˜¯å› ä¸ºå…¶ æ˜¯ one lock queue çš„å®ç°ã€‚)**

    - ```java
            public void put(E e) throws InterruptedException {
                if (e == null) throw new NullPointerException();
                final int c;
                final Node<E> node = new Node<E>(e);
                final ReentrantLock putLock = this.putLock;
                final AtomicInteger count = this.count;		// ç»†èŠ‚1:åŸå­ç±»å‹ count
                putLock.lockInterruptibly();
                try {
                    /*
                     * Note that count is used in wait guard even though it is
                     * not protected by lock. This works because count can
                     * only decrease at this point (all other puts are shut
                     * out by lock), and we (or some other waiting put) are
                     * signalled if it ever changes from capacity. Similarly
                     * for all other uses of count in other wait guards.
                     */
                    while (count.get() == capacity) {
                        notFull.await();
                    }
                    enqueue(node);
                    c = count.getAndIncrement();
                    if (c + 1 < capacity)		// ç»†èŠ‚2ï¼š å¦‚æœ c + 1 < capacityï¼Œè¯´æ˜é˜Ÿåˆ—æœªæ»¡ï¼Œé€šçŸ¥ ç”Ÿäº§è€…ç”Ÿäº§
                        notFull.signal();
                } finally {
                    putLock.unlock();
                }
                if (c == 0)					// ç»†èŠ‚3ï¼šå¦‚æœ c == 0 è¯´æ˜é˜Ÿåˆ—åœ¨åŠ å…¥nodeä¹‹å‰ä¸ºç©º(ä»0 -> 1), æ‰é€šçŸ¥æ¶ˆè´¹è€…take
                    signalNotEmpty();
            }
        ```

    - ```java
            public E take() throws InterruptedException {
                final E x;
                final int c;
                final AtomicInteger count = this.count;			// ç»†èŠ‚1:åŸå­ç±»å‹ count
                final ReentrantLock takeLock = this.takeLock;
                takeLock.lockInterruptibly();
                try {
                    while (count.get() == 0) {
                        notEmpty.await();
                    }
                    x = dequeue();
                    c = count.getAndDecrement();
                    if (c > 1)						// ç»†èŠ‚2ï¼š å¦‚æœ c > 1ï¼Œè¯´æ˜é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œé€šçŸ¥ æ¶ˆè´¹è€…æ¶ˆè´¹takes
                        notEmpty.signal();
                } finally {
                    takeLock.unlock();
                }
                if (c == capacity)			// ç»†èŠ‚3ï¼šå¦‚æœc==capacity è¯´æ˜é˜Ÿåˆ—åœ¨æ¶ˆè´¹nodeä¹‹å‰ä¸ºæ»¡(ä»full->full-1)ï¼Œé€šçŸ¥ç”Ÿäº§è€…puts
                    signalNotFull();
                return x;
            }
        ```

---

###### PriorityBlockingQueue

â€‹	PriorityBlockingQueue æ˜¯ä¸€ä¸ªæ”¯æŒä¼˜å…ˆçº§çš„æ— ç•Œçš„é˜»å¡é˜Ÿåˆ—ï¼Œåº•å±‚ç”± **æ•°ç»„** å®ç°ã€‚é»˜è®¤æƒ…å†µä¸‹ä½¿ç”¨è‡ªç„¶é¡ºåºå‡åºæ’åºï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ **Comparator** æ¥å®šä¹‰æ’åºè§„åˆ™äº†ã€‚

ä¼˜å…ˆé˜»å¡é˜Ÿåˆ—çš„**æ³¨æ„äº‹é¡¹**ï¼š

- é˜Ÿåˆ—ä¸­ä¸å…è®¸ null å€¼ï¼Œä¹Ÿä¸å…è®¸å­˜åœ¨ä¸èƒ½æ’åºçš„å…ƒç´ ã€‚

- å¯¹äºæ’åºå€¼ç›¸åŒçš„å…ƒç´ ï¼Œå…¶åºåˆ—æ˜¯ä¸ä¿è¯çš„(å«ä»€ä¹ˆï¼Ÿ"ä¸å®‰å…¨æ’åºï¼Ÿ")ï¼Œä½†æˆ‘ä»¬å¯ä»¥è‡ªå·±ç»§ç»­å®šä¹‰ä¼˜å…ˆçº§ï¼Œä»¥æ»¡è¶³å­˜åœ¨ä¸¥æ ¼åŒºåˆ†çš„ä¼˜å…ˆçº§åŒºåˆ«ï¼Œæ¯”å¦‚ **ä½¿ç”¨ ç‰ˆæœ¬å· AtomicLong seq ++**ï¼Œå¦‚ä¸‹ï¼š

    - ```java
        class FIFOEntry<E extends Comparable<? super E>> implements Comparable<FIFOEntry<E>> {
            static final AtomicLong seq = new AtomicLong(0);
            final long seqNum;
            final E entry;
            public FIFOEntry(E entry) {
                seqNum = seq.getAndIncrement();
                this.entry = entry;
            }
            
            public E getEntry() { return entry; }
            
            @Override
            public int compareTo(FIFOEntry<E> other) {
                int res = entry.compareTo(other.entry);
                if (res == 0 && other.entry != this.entry) {
        			res = (seqNum < other.seqNum ? -1: 1);
                }
                return res;
            }
        }
        ```

- é˜Ÿåˆ—å®¹é‡æ˜¯æ²¡æœ‰ä¸Šé™çš„ï¼Œä½†æ˜¯å¦‚æœæ’å…¥çš„å…ƒç´ è¶…è¿‡è´Ÿè½½ï¼Œæœ‰å¯èƒ½ä¼šå¼•èµ· OOMï¼Œè¿™å°±æ˜¯æˆ‘ä»¬è¯´çš„ï¼Œé˜Ÿåˆ—æ— ç•Œï¼Œå¿ƒä¸­æœ‰ç•Œã€‚

- PriorityBlockingQueue ä¸­ä¹Ÿæœ‰putæ–¹æ³•ï¼Œä½†ç”±äºå®ƒæ˜¯æ— ç•Œçš„ï¼Œè‡ªç„¶ä¹Ÿä¸ä¼šé˜»å¡ï¼Œæ‰€ä»¥ JDK è¯¥putæ–¹æ³•å…¶å®å°±æ˜¯è°ƒç”¨çš„ offer()ã€‚

    - ```java
        public void put(E e) {
            offer(e); // never need to block  è¯·è‡ªè¡Œå¯¹ç…§ä¸Šé¢è¡¨æ ¼
        }
        ```

- å¯ä»¥ç»™å®šåˆå§‹å®¹é‡ã€‚è¿™ä¸ªå®¹é‡ä¼šæŒ‰ç…§ä¸€å®šçš„ç®—æ³•è‡ªåŠ¨æ‰©å®¹ã€‚æœ€å¤§å®¹é‡ä¸º Integer.MAX_VALUE - 8, jvmä¸ºæ•°ç»„é¢„ç•™äº†ä¸€äº› head wordsã€‚

    - ```java
        // Default array capacity.
        private static final int DEFAULT_INITIAL_CAPACITY = 11;
        
        public PriorityBlockingQueue() {
            this(DEFAULT_INITIAL_CAPACITY, null);
        }
        ```

---

###### DelayQueue

DelayQueue æ˜¯ä¸€ä¸ªæ”¯æŒå»¶æ—¶è·å–å…ƒç´ çš„æ— ç•Œé˜»å¡é˜Ÿåˆ—ã€‚

- æ˜¯å¦å»¶æ—¶è‚¯å®šéœ€è¦å’ŒæŸä¸ªæ—¶é—´(é€šå¸¸å’Œå½“å‰æ—¶é—´)è¿›è¡Œ **æ¯”è¾ƒ**
- æ¯”è¾ƒè¿‡åè¿˜éœ€è¦ æ’åºï¼Œæ‰€ä»¥ä¹Ÿå­˜åœ¨ **ä¼˜å…ˆçº§**

æ˜¯çš„ï¼Œæ²¡é”™ï¼ŒDelayQueue å†…éƒ¨ä½¿ç”¨çš„å°±æ˜¯ PriorityQueue ä¼˜å…ˆé˜Ÿåˆ—(ps:å’ŒPriorityBlockingQueueä¸åŒï¼ŒPBQç›´æ¥ä½¿ç”¨åŸç”Ÿæ•°ç»„ã€‚)

![img](https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-img20200819112551.png)

![img](https://rgyb.sunluomeng.top/20200819112927.png)

ä½¿ç”¨ DelayQueue éå¸¸ç®€å•ï¼Œåªéœ€è¦ä¸¤æ­¥ï¼š

1. å®ç° **getDelay()æ–¹æ³•ï¼Œè¿”å›å…ƒç´ è¦å»¶æ—¶å¤šé•¿æ—¶é—´ã€‚**

    - ```java
        public long getDelay(TimeUnit unit) {
          	// æœ€å¥½é‡‡ç”¨çº³ç§’å½¢å¼ï¼Œè¿™æ ·æ›´ç²¾ç¡®
            return unit.convert(time - now(), NANOSECONDS);
        }
        ```

2. å®ç° **compareTo() æ–¹æ³•ï¼Œæ¯”è¾ƒå…ƒç´ é¡ºåºã€‚**

    - ```java
        public int compareTo(Delayed other) {
            if (other == this) // compare zero if same object
                return 0;
            if (other instanceof ScheduledFutureTask) {
                ScheduledFutureTask<?> x = (ScheduledFutureTask<?>)other;
                long diff = time - x.time;
                if (diff < 0)
                    return -1;
                else if (diff > 0)
                    return 1;
                else if (sequenceNumber < x.sequenceNumber)
                    return -1;
                else
                    return 1;
            }
            long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);
            return (diff < 0) ? -1 : (diff > 0) ? 1 : 0;
        }
        ```

ä¸Šé¢çš„ä»£ç å“ªæ¥çš„å‘¢ï¼Ÿå¦‚æœä½ æ‰“å¼€ **ScheduledThreadPoolExecutor** é‡Œçš„ **ScheduledFutureTask**ï¼Œä½ å°±çœ‹åˆ°äº† ï¼ˆ**ScheduledThreadPoolExecutor** å†…éƒ¨å°±æ˜¯åº”ç”¨ **DelayQueue**ï¼‰

**DelayQueueçš„åº”ç”¨åœºæ™¯ï¼š**

- ç¼“å­˜ç³»ç»Ÿçš„è®¾è®¡ï¼šä½¿ç”¨ DelayQueue ä¿å­˜ç¼“å­˜å…ƒç´ çš„æœ‰æ•ˆæœŸï¼Œä½¿ç”¨ä¸€ä¸ªçº¿ç¨‹å¾ªç¯æŸ¥è¯¢DelayQueueï¼Œå¦‚æœèƒ½ä»DelayQueueä¸­è·å–å…ƒç´ ï¼Œè¯´æ˜ç¼“å­˜åˆ°æœŸã€‚
- å®šæ—¶ä»»åŠ¡è°ƒåº¦ï¼šç”¨DelayQueueä¿å­˜å½“å¤©ä¼šæ‰§è¡Œçš„ä»»åŠ¡åŠæ—¶é—´ï¼Œå¦‚æœèƒ½ä»DelayQueueä¸­è·å–å…ƒç´ ï¼Œè¯´æ˜ä»»åŠ¡å¯ä»¥å¼€å§‹æ‰§è¡Œï¼Œæ¯”å¦‚ TimerQueueå°±æ˜¯è¿™æ ·å®ç°çš„ã€‚

---

###### SynchronousQueue

![img](https://rgyb.sunluomeng.top/20200820220134.png)

è¿™æ˜¯ä¸€ä¸ª**ä¸å­˜å‚¨å…ƒç´ **çš„é˜»å¡é˜Ÿåˆ—ï¼Œä¸å­˜å‚¨å…ƒç´ è¿˜å«é˜Ÿåˆ—ï¼Ÿ

æ²¡é”™ï¼ŒSynchronousQueue ç›´è¯‘è¿‡æ¥å«**åŒæ­¥é˜Ÿåˆ—**ï¼Œå¦‚æœåœ¨é˜Ÿåˆ—é‡Œé¢å‘†ä¹…äº†åº”è¯¥å°±ç®—æ˜¯â€œå¼‚æ­¥â€äº†å§

æ‰€ä»¥ä½¿ç”¨å®ƒï¼Œ**æ¯ä¸ªput() æ“ä½œå¿…é¡»è¦ç­‰å¾…ä¸€ä¸ª take() æ“ä½œï¼Œåä¹‹äº¦ç„¶ï¼Œå¦åˆ™ä¸èƒ½ç»§ç»­æ·»åŠ å…ƒç´ **

å®é™…ä¸­æ€ä¹ˆç”¨å‘¢ï¼Ÿ**å‡å¦‚ä½ éœ€è¦ä¸¤ä¸ªçº¿ç¨‹ä¹‹é—´åŒæ­¥å…±äº«å˜é‡**ï¼Œå¦‚æœä¸ç”¨ SynchronousQueue ä½ å¯èƒ½ä¼šé€‰æ‹©ç”¨ CountDownLatch æ¥å®Œæˆï¼Œå°±åƒè¿™æ ·ï¼š

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
AtomicInteger sharedState = new AtomicInteger();
CountDownLatch countDownLatch = new CountDownLatch(1);

Runnable producer = () -> {
    Integer producedElement = ThreadLocalRandom
      .current()
      .nextInt();
    sharedState.set(producedElement);
    countDownLatch.countDown();
};

Runnable consumer = () -> {
    try {
        countDownLatch.await();
        Integer consumedElement = sharedState.get();
    } catch (InterruptedException ex) {
        ex.printStackTrace();
    }
};
```

è¿™ç‚¹å°äº‹å°±ç”¨è®¡æ•°å™¨æ¥å®ç°ï¼Œæ˜¾ç„¶å¾ˆä¸åˆé€‚ï¼Œç”¨ SynchronousQueue æ”¹é€ ä¸€ä¸‹ï¼Œæ„Ÿè§‰ç¬é—´å°±ä¸ä¸€æ ·äº†

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
SynchronousQueue<Integer> queue = new SynchronousQueue<>();

Runnable producer = () -> {
    Integer producedElement = ThreadLocalRandom
      .current()
      .nextInt();
    try {
        queue.put(producedElement);
    } catch (InterruptedException ex) {
        ex.printStackTrace();
    }
};

Runnable consumer = () -> {
    try {
        Integer consumedElement = queue.take();
    } catch (InterruptedException ex) {
        ex.printStackTrace();
    }
};
```

å…¶å® **Executors.newCachedThreadPool()** æ–¹æ³•é‡Œé¢ä½¿ç”¨çš„å°±æ˜¯ SynchronousQueue

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

å› ä¸º**å•çº¿ç¨‹æ± å’Œå›ºå®šçº¿ç¨‹æ± ä¸­ï¼Œçº¿ç¨‹æ•°é‡æ˜¯æœ‰é™çš„**ï¼Œå› æ­¤æäº¤çš„ä»»åŠ¡éœ€è¦åœ¨**`LinkedBlockingQueue`**é˜Ÿåˆ—ä¸­ç­‰å¾…ç©ºä½™çš„çº¿ç¨‹ï¼›

è€Œ**ç¼“å­˜çº¿ç¨‹æ± ä¸­ï¼Œçº¿ç¨‹æ•°é‡å‡ ä¹æ— é™**ï¼ˆä¸Šé™ä¸º`Integer.MAX_VALUE`ï¼‰ï¼Œå› æ­¤æäº¤çš„ä»»åŠ¡åªéœ€è¦åœ¨**`SynchronousQueue`** é˜Ÿåˆ—ä¸­**åŒæ­¥ç§»äº¤ç»™ç©ºä½™çº¿ç¨‹**å³å¯, æ‰€ä»¥æœ‰æ—¶ä¹Ÿä¼šè¯´ **`SynchronousQueue` çš„ååé‡è¦é«˜äº `LinkedBlockingQueue` å’Œ `ArrayBlockingQueue`**



###### LinkedTransferQueue

ç®€å•æ¥è¯´ï¼ŒTransferQueueæä¾›äº†ä¸€ä¸ªåœºæ‰€ï¼Œç”Ÿäº§è€…çº¿ç¨‹ä½¿ç”¨ `transfer` æ–¹æ³•ä¼ å…¥ä¸€äº›å¯¹è±¡å¹¶é˜»å¡ï¼Œç›´è‡³è¿™äº›å¯¹è±¡è¢«æ¶ˆè´¹è€…çº¿ç¨‹å…¨éƒ¨å–å‡ºã€‚

> ä½ æœ‰æ²¡æœ‰è§‰å¾—ï¼Œåˆšåˆšä»‹ç»çš„ **SynchronousQueue** æ˜¯å¦å¾ˆåƒä¸€ä¸ªå®¹é‡ä¸º 0 çš„ **TransferQueue**ã€‚

ä½† LinkedTransferQueue ç›¸æ¯”å…¶ä»–é˜»å¡é˜Ÿåˆ—å¤šäº†ä¸‰ä¸ªæ–¹æ³•

- **transfer(E e)**

    å¦‚æœå½“å‰æœ‰æ¶ˆè´¹è€…æ­£åœ¨ç­‰å¾…æ¶ˆè´¹å…ƒç´ ï¼Œtransfer æ–¹æ³•å°±å¯ä»¥ç›´æ¥å°†ç”Ÿäº§è€…ä¼ å…¥çš„å…ƒç´ ç«‹åˆ» transfer (ä¼ è¾“) ç»™æ¶ˆè´¹è€…ï¼›å¦‚æœæ²¡æœ‰æ¶ˆè´¹è€…ç­‰å¾…æ¶ˆè´¹å…ƒç´ ï¼Œé‚£ä¹ˆ transfer æ–¹æ³•ä¼šæŠŠå…ƒç´ æ”¾åˆ°é˜Ÿåˆ—çš„ tail(å°¾éƒ¨)èŠ‚ç‚¹ï¼Œä¸€ç›´é˜»å¡ï¼Œç›´åˆ°è¯¥å…ƒç´ è¢«æ¶ˆè´¹è€…æ¶ˆè´¹æ‰è¿”å›

- **tryTransfer(E e)**

    tryTransferï¼Œå¾ˆæ˜¾ç„¶æ˜¯ä¸€ç§å°è¯•ï¼Œå¦‚æœæ²¡æœ‰æ¶ˆè´¹è€…ç­‰å¾…æ¶ˆè´¹å…ƒç´ ï¼Œåˆ™é©¬ä¸Šè¿”å› false ï¼Œç¨‹åºä¸ä¼šé˜»å¡

- **tryTransfer(E e, long timeout, TimeUnit unit)**

    å¸¦æœ‰è¶…æ—¶é™åˆ¶ï¼Œå°è¯•å°†ç”Ÿäº§è€…ä¼ å…¥çš„å…ƒç´  transfer ç»™æ¶ˆè´¹è€…ï¼Œå¦‚æœè¶…æ—¶æ—¶é—´åˆ°ï¼Œè¿˜æ²¡æœ‰æ¶ˆè´¹è€…æ¶ˆè´¹å…ƒç´ ï¼Œåˆ™è¿”å› false

ä½ ç§ï¼Œæ‰€æœ‰é˜»å¡çš„æ–¹æ³•éƒ½æ˜¯ä¸€ä¸ªå¥—è·¯ï¼š

1. é˜»å¡æ–¹å¼
2. å¸¦æœ‰ try çš„éé˜»å¡æ–¹å¼
3. å¸¦æœ‰ try å’Œè¶…æ—¶æ—¶é—´çš„éé˜»å¡æ–¹å¼

çœ‹åˆ°è¿™ä½ ä¹Ÿè®¸æ„Ÿè§‰ **LinkedTransferQueue** æ²¡å•¥ç‰¹ç‚¹ï¼Œå…¶å®å®ƒå’Œå…¶ä»–é˜»å¡é˜Ÿåˆ—çš„å·®åˆ«è¿˜æŒºå¤§çš„ï¼š

**BlockingQueue æ˜¯å¦‚æœé˜Ÿåˆ—æ»¡äº†ï¼Œçº¿ç¨‹æ‰ä¼šé˜»å¡ï¼›ä½†æ˜¯ TransferQueue æ˜¯å¦‚æœæ²¡æœ‰æ¶ˆè´¹å…ƒç´ ï¼Œåˆ™ä¼šé˜»å¡ ï¼ˆtransfer æ–¹æ³•ï¼‰**



è¿™å°±æ˜¯Doug Lea è¯´çš„ï¼š

`LinkedTransferQueue` is actually a superset of `ConcurrentLinkedQueue`, `SynchronousQueue` (in â€œfairâ€ mode), and unbounded
`LinkedBlockingQueues`. And itâ€™s made better by allowing you to mix and
match those features as well as take advantage of higher-performance i
mplementation techniques.

**ç®€å•ç¿»è¯‘ï¼š**

`LinkedTransferQueue` æ˜¯`ConcurrentLinkedQueue`, `SynchronousQueue` (åœ¨å…¬å¹³æ¨¡å¼ä¸‹), æ— ç•Œçš„`LinkedBlockingQueues`ç­‰çš„è¶…é›†; å…è®¸ä½ æ··åˆä½¿ç”¨é˜»å¡é˜Ÿåˆ—çš„å¤šç§ç‰¹æ€§

**æ‰€ä»¥ï¼Œåœ¨åˆé€‚çš„åœºæ™¯ä¸­ï¼Œè¯·å°½é‡ä½¿ç”¨`LinkedTransferQueue`**



###### LinkedBlockingDeque

`LinkedBlockingDeque` æ˜¯ä¸€ä¸ªç”±é“¾è¡¨ç»“æ„ç»„æˆçš„åŒå‘é˜»å¡é˜Ÿåˆ—ï¼Œå‡¡æ˜¯åç¼€ä¸º Deque çš„éƒ½æ˜¯åŒå‘é˜Ÿåˆ—æ„æ€ï¼Œåç¼€çš„å‘éŸ³ä¸º`deckâ€”â€”/dek/`, åˆšæ¥è§¦å®ƒæ—¶æˆ‘ä»¥ä¸ºæ˜¯å†°æ¿€å‡Œçš„å‘éŸ³ã€‚

